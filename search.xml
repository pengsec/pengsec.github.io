<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux服务器基础知识</title>
      <link href="/posts/8b0b.html"/>
      <url>/posts/8b0b.html</url>
      
        <content type="html"><![CDATA[<h2 id="登录tty的快捷键">登录tty的快捷键</h2><ul class="lvl-0"><li class="lvl-2">Ctrl + Alt + F1：<strong>回到图形界面</strong></li><li class="lvl-2">Ctrl + Alt + F2：terminal 1（:0 大致等于tty 1）</li><li class="lvl-2">Ctrl + Alt + F3：terminal 2（tty2）</li><li class="lvl-2">Ctrl + Alt + F4：terminal 4（tty 3）</li><li class="lvl-2">Ctrl + Alt + F5：terminal 4（tty4）</li></ul><h2 id="打开图形模式终端的方式">打开图形模式终端的方式</h2><ul class="lvl-0"><li class="lvl-2"><p>调出系统搜索框，在搜索框中输入”terminal“</p></li><li class="lvl-2"><p>用快捷键来调出终端，比如可以自己设置快捷键：Ctrl + Alt + T</p></li></ul><h2 id="命令行">命令行</h2><ul class="lvl-0"><li class="lvl-2"><p>切换成root身份：<mark>sudo su</mark></p></li><li class="lvl-2"><p>退出root身份，可以用Ctrl + D 的组合键，或者用exit命令</p></li><li class="lvl-2"><p>检测当前用户身份命令：<mark>whoami</mark></p></li><li class="lvl-2"><p>检测当前主机名：<mark>hostname</mark></p></li><li class="lvl-2"><p>Linux的开发者们写了丰富详尽的命令使用手册，英语是<mark>manual</mark></p></li><li class="lvl-2"><p>显示当前日期信息：<mark>date</mark></p><p><mark>CST</mark>是Central Standard Time的缩写，表示“中央标准时间”</p></li><li class="lvl-2"><p>ls命令：ls是list的缩写。list是“列举，列出”的意思</p></li><li class="lvl-2"><p>命令参数：</p><p>参数是写在命令之后的一些补充选项。命令和参数之间有空格隔开</p><ol><li class="lvl-5"><p>短参数（一个字母）</p><ul class="lvl-4"><li class="lvl-7"><p>最常用的参数形式就是一个短横线后接一个字母：command -p</p></li><li class="lvl-7"><p>一次加好几个参数，可以用空格隔开：command -p -a -T -c</p></li><li class="lvl-7"><p>多个短参数也可以合并在一起：command -paTc</p></li><li class="lvl-7"><p>字母的大小写有区别，大写的T和小写的t通常含义不同</p></li></ul></li><li class="lvl-5"><p>长参数（多个字母）</p><ul class="lvl-4"><li class="lvl-7"><p>短参数是以一个短横线开始，而长参数是以两个短横线开始的</p></li><li class="lvl-7"><p>多格长参数，是不能像多个短参数那样合并写的</p></li><li class="lvl-7"><p>可以组合使用短参数和长参数</p></li><li class="lvl-7"><p>有时候，同一个意义的参数有短参数和长参数两种形式</p><p>效果是一样的：例如<mark>ls -a</mark>和<mark>ls --all</mark></p></li></ul></li><li class="lvl-5"><p>参数的值</p><ul class="lvl-4"><li class="lvl-7">有一些参数需要赋值。短参数和长参数的赋值方式不一样</li><li class="lvl-7">短参数赋值，通常是这样：command -p 10</li><li class="lvl-7">长参数赋值，通常是这样的：command --paremeter=10</li></ul></li></ol></li></ul><h2 id="如何查找命令和命令历史记录">如何查找命令和命令历史记录</h2><h3 id="如何找到一个命令">如何找到一个命令</h3><ul class="lvl-0"><li class="lvl-2"><p>有时候会想不起一个命令到底是如何拼写的</p></li><li class="lvl-2"><p>Linux的开发者们早就为我们准备了对策：用Tab键补全命令</p></li><li class="lvl-2"><p>Tab键可以补全命令，也可以补全文件名、路径名：按两次Tab键</p><blockquote><p>技巧：</p><ul class="lvl-3"><li class="lvl-2"><p>按一个下空格键，切换下一页</p></li><li class="lvl-2"><p>按一下回车键切换下一行</p></li><li class="lvl-2"><p>按一下Q键退出</p></li></ul></blockquote></li></ul><h3 id="命令的历史记录">命令的历史记录</h3><ul class="lvl-0"><li class="lvl-2"><p>向上键：按时间顺序向前查找用过的命令，每按一次就前进一个命令</p></li><li class="lvl-2"><p>向下键：按时间顺序向后查找用过的命令，每按一次就前进一个命令</p></li><li class="lvl-2"><p><mark>Ctrl + R</mark>：用于查找使用过的命令</p></li><li class="lvl-2"><p><mark>history</mark>命令：用于列出之前使用过的所有命令</p></li><li class="lvl-2"><p>可以用==！编号==这样的格式来重新运行history输出中对应编号的命令</p></li></ul><h2 id="一些实用的快捷键">一些实用的快捷键</h2><ul class="lvl-0"><li class="lvl-2"><p>Ctrl + L：用于清理终端的内容，就是清屏的作用。同clear命令</p></li><li class="lvl-2"><p>Ctrl + D给终端传递EOF（End Of File，文件结束符）</p></li><li class="lvl-2"><p>Shift + PgUp用于向上滚屏，与鼠标的滚轮向上滚屏是一个效果</p></li><li class="lvl-2"><p>Shift + PgDn 用于向下滚屏，与鼠标的滚轮向下滚屏是一个效果</p></li><li class="lvl-2"><p>Ctrl + A 光标跳到一行命令的开头。Home键有相同的效果</p></li><li class="lvl-2"><p>Ctrl + E 光标跳到一行命令的结尾。End键有相同的效果</p></li><li class="lvl-2"><p>Ctrl + U 删除所有在光标左侧的命令字符</p></li><li class="lvl-2"><p>Ctrl + K 删除所有光标右侧的命令字符</p></li><li class="lvl-2"><p>Ctrl + W删除光标左侧的一个“单词”</p><p>“单词”指用空格隔开的一个字符串。例如 -a 就是一个“单词”</p></li><li class="lvl-2"><p>Ctrl + Y 粘贴用 Ctrl + U，Ctrl + K</p><p>或Ctrl + W “删除”的字符串，有点像“剪切-粘贴”</p></li></ul><h2 id="文件组织">文件组织</h2><h3 id="Linux中两种类型的文件">Linux中两种类型的文件</h3><p>分类：</p><ol><li class="lvl-3"><p>普通的文件</p></li><li class="lvl-3"><p>特殊的文件</p></li></ol><p><strong>普通的文件：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>文本类型的文件（.txt，.doc，.odt，等等）</p></li><li class="lvl-2"><p>声音文件（.wav，.mp3，.ogg），还有程序，等</p></li></ul><p><strong>特殊的文件：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>其他一些文件时特殊的，因为它们表示一些东西</p><p>例如，你的光盘驱动器就是这类特殊的文件</p></li></ul><h3 id="根目录">根目录</h3><p><strong>windows中</strong></p><ul class="lvl-0"><li class="lvl-2"><p>可以有好几个根目录</p></li><li class="lvl-2"><p>C盘（C:\）是硬盘的根目录（假如没有把C盘分区的话）</p></li><li class="lvl-2"><p>H盘可能是光盘驱动器的根目录</p></li><li class="lvl-2"><p>一个目录的形式是这样的<mark>C:\Program Files\Baidu</mark></p><ul class="lvl-2"><li class="lvl-4">Baidu这个目录是Program Files这个目录的一个子目录</li><li class="lvl-4">Program Files这个目录是C盘这个目录的一个子目录</li><li class="lvl-4">Windows中用反斜杠 \ 来表明目录的层级与包含关系</li></ul></li></ul><p><strong>Linux中：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>Linux有且只有一个根目录，就是 / (斜杠)</p></li><li class="lvl-2"><p>Linux中没有比根目录再高一阶的目录了，没有目录包含根目录</p></li><li class="lvl-2"><p>Linux中用斜杠 / 来标明目录层级与包含关系</p><p>Linux的目录形式是这样的 /usr/bin</p><p>bin 是usr目录的子目录，usr 是 / 这个根目录的子目录</p></li></ul><h3 id="根目录的直属子目录">根目录的直属子目录</h3><p><strong>Windows的根目录的直属子目录：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>Windows的C盘这个根目录下一般都会找到一些相同的子目录</p></li></ul><p><strong>Linux的根目录的直属子目录：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>bin：英语binary的缩写，表示“二进制文件”，可执行文件为二进制文件，bin目录包含了会被所有用户使用的可执行程序</p></li><li class="lvl-2"><p>boot：英语boot表示“启动”，boot目录包含与Linux启动密切相关的文件</p></li><li class="lvl-2"><p>dev：英语device的缩写，表示“设备”</p><p>包含外设，它里面的子目录，每一个对应一个外设，比如代表光盘驱动器的文件就会出现在这个目录下面</p></li><li class="lvl-3"><p>etc：etc是法语et cetera的缩写，翻译成英语就是and so on，表示“……等等”</p></li></ul><p>etc目录包含系统的配置文件</p><ul class="lvl-0"><li class="lvl-2"><p>home：英语home表示“家”。用户的私人目录</p><p>在home目录中，放置私人的文件。类似Windows中的Documents文件夹，也叫“我的文档”</p><p>Linux中每个用户都在home目录下有一个私人目录（除了root）</p></li><li class="lvl-2"><p>lib：英语library的缩写，表示“库”</p><p>lib目录包含被程序所调用的库文件，例如 .so 结尾的文件</p><p><mark>Windows下这样的库文件则是以.dll结尾</mark></p></li><li class="lvl-2"><p>media：英语media表示“媒体”</p><p>可移动的外设（USB盘，SD卡，DVD，光盘，等等）插入电脑时，Linux可以让我们通过media的子目录来访问这些外设中的内容</p></li><li class="lvl-2"><p>mnt：英语mount的缩写，表示“挂载”</p><p>有点类似media目录，但一般用于临时挂载一些装置</p></li><li class="lvl-2"><p>opt：英语 optional application software package 的缩写</p><p>表示“可选的应用软件包”，用于安装多数第三方软件和插件</p></li><li class="lvl-2"><p>root：英语“根”的意思</p><p>超级用户root的根目录，一般的用户的根目录位于 /home下，root用户是个例外</p></li><li class="lvl-2"><p>sbin：英语system binary 的缩写，表示“系统二进制文件”</p><p>比bin目录多了一个前缀system（“系统”），sbin目录包含系统级的重要可执行程序</p></li><li class="lvl-2"><p>srv：英语service的缩写，表示“服务”</p><p>包含一些网络服务启动之后所需要的取用的数据</p></li><li class="lvl-2"><p>tmp：英语tamporary的缩写，表示“临时的”</p><p>普通用户和程序存放临时文件的地方</p></li><li class="lvl-2"><p>usr：是英语Unix Software Resource的缩写</p><p>表示“Unix操作系统软件资源（类似etc，属于历史遗留的命名），ust是最庞大的目录之一，类似Windows中的<mark>C:\Windows</mark>和<mark>C:\Program Files</mark>这两个文件夹的集合，usr目录里安装了大部分用户要调用的程序</p></li><li class="lvl-2"><p>var：英语variable的缩写，表示”动态的，可变的“</p><p>通常包含程序的数据，比如log（日志）文件</p></li></ul><p>以上目录的列表形式，在类Unix的操作系统里类似的</p><p><strong>参考资料：</strong><a href="https://linuxtoy.org/archives/linux-file-structure.html">Linux 文件结构 </a></p><blockquote><p>目录注意事项：</p><ul class="lvl-1"><li class="lvl-2">Windows的目录名称可以包含空格等符号，Linux也可以</li><li class="lvl-2">一般在Linux下命名目录时尽量不使用空格或者其他特殊的符号</li><li class="lvl-2">尽量用小写英文字母。这会省去一些不必要的麻烦</li></ul></blockquote><h2 id="pwd命令">pwd命令</h2><ul class="lvl-0"><li class="lvl-2"><p>pwd是Print Working Directory（”打印当前工作目录“）的缩写</p></li><li class="lvl-2"><p>显示当前目录的路径</p></li></ul><h2 id="which命令">which命令</h2><ul class="lvl-0"><li class="lvl-2"><p>用于显示一个命令的对应的可执行文件的位置</p></li><li class="lvl-2"><p>Linux下，每一条命令其实对应了一个可执行程序</p><p>在终端汇总输入命令，按回车键的时候，就是执行了对应的那个程序，如，pwd命令对应的pwd程序就是存在于Linux中的 /usr/bin 目录中</p></li><li class="lvl-2"><p>which命令接受一个参数，参数是你想知道可执行程序位于哪里的那个命令</p></li></ul><blockquote><p>注：Windows可执行程序以.exe结尾，Linux中一般是没有后缀名的。</p></blockquote><h2 id="ls命令">ls命令</h2><ul class="lvl-0"><li class="lvl-2"><p>ls命令：列出文件和目录</p></li><li class="lvl-2"><p>可以加上参数 --color=auto 来开启颜色：<mark>ls --color=auto</mark></p></li><li class="lvl-2"><p>可以用 --color=none来关闭颜色标注：<mark>ls --color=none</mark></p></li></ul><p><strong>ls 常用的参数：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>-a：显示所有文件和目录，包括隐藏的</p></li><li class="lvl-2"><p>-A：它的作用和小写的==-a<mark>几乎一样，唯一不同的是</mark>-A== 不列出==.== 和 <mark>…</mark> 这两个文件</p></li><li class="lvl-2"><p>-l：使得ls命令列出一个显示文件和目录的详细信息的列表</p><p>每一个文件或目录都有对应的详细信息</p><p><mark>如文件权限：drwxr-xr-x之类</mark></p></li><li class="lvl-2"><p>-h：以Ko，Mo，Go的形式显示文件大小</p><p><mark>ls -l</mark>，列出的文件详细信息中，文件大小是以字节为单位的</p><p>参数==-h==，h是humain readable的缩写，表示“适合人类阅读的”</p></li><li class="lvl-2"><p>-t：按文件最近一次修改时间排序</p><p>t是time的缩写，表示“时间”</p><p>ls的常用参数合并在一起使用，效果是叠加的：<mark>ls -lath</mark></p></li></ul><blockquote><ul class="lvl-1"><li class="lvl-2"><p>Linux中，以点（.）开头的文件是隐藏文件</p></li><li class="lvl-2"><p>不包括开头的两个 <mark>.</mark> 和 <mark>…</mark> ，这两个的含义如下：</p></li><li class="lvl-2"><p><mark>.</mark>  (一个点）表示当前目录；<mark>…</mark>（两个点）表示上一级目录</p></li></ul></blockquote><h2 id="cd命令">cd命令</h2><ul class="lvl-0"><li class="lvl-2"><p>cd 是英语 change directory的缩写，表示“切换目录”</p></li><li class="lvl-2"><p>cd命令后面接的参数就是一个：去的那个目录的路径</p></li><li class="lvl-2"><p>要返回上一级目录：<mark>cd …</mark></p></li><li class="lvl-2"><p>进入当前目录：<mark>cd .</mark></p></li><li class="lvl-2"><p>连续退回两个父目录：<mark>cd …/…</mark></p></li><li class="lvl-2"><p>回到根目录：<mark>cd /</mark> 或 <mark>cd ~</mark></p></li><li class="lvl-2"><p>相对路径：相对当前目录的一个路径表示法</p></li><li class="lvl-2"><p>绝对路径：绝对的，不因当前目录而改变的一个路径表示法</p><p>总是以 ==/<mark>开头，</mark>/==表示根目录</p></li><li class="lvl-2"><p>重回家目录的三种办法</p><ul class="lvl-2"><li class="lvl-4">cd /home/username，username可替换为你的用户名</li><li class="lvl-4">cd ~</li><li class="lvl-4">cd，不加任何参数</li></ul></li></ul><blockquote><p>路径自动补充：</p><ul class="lvl-1"><li class="lvl-2">Tab键可以进行命令的补充（按两下Tab键）</li><li class="lvl-2">其实Tab键还可以用于路径的补全</li></ul></blockquote><h2 id="du命令">du命令</h2><ul class="lvl-0"><li class="lvl-2"><p>显示目录包含的文件大小</p></li><li class="lvl-2"><p>相比ls -l命令，du命令统计的才是真正的文件大小</p></li><li class="lvl-2"><p>du命令会深入遍历每个目录的子目录，统计所有文件的大小</p></li><li class="lvl-2"><p>du是英语disk usage的缩写，表示“磁盘使用/占用”</p></li><li class="lvl-2"><p>适合人类阅读的文件大小命令：<mark>du -h</mark></p></li><li class="lvl-2"><p>-a：显示文件和目录的大小</p></li><li class="lvl-2"><p>-s：只显示总计大小</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>misc的基本解题思路(二)</title>
      <link href="/posts/e560.html"/>
      <url>/posts/e560.html</url>
      
        <content type="html"><![CDATA[<p><strong>misc的四大部分：</strong></p><ul class="lvl-0"><li class="lvl-2">文件操作与隐写</li><li class="lvl-2">图片隐写术</li><li class="lvl-2">压缩文件处理</li><li class="lvl-2">流量取证技术</li></ul><h2 id="压缩文件处理">压缩文件处理</h2><h3 id="压缩文件分析">压缩文件分析</h3><ol><li class="lvl-3"><p><strong>伪加密</strong></p><p>如果压缩文件是加密的，或文件头正常但解压缩错误，首先尝试文件是否为伪加密。zip文件是否加密是通过识别符来显示的，在每个文件的文件目录字段有一位专门标识了文件是否加密，将其设置为00表示</p><p><mark>使用场景：伪加密文件</mark></p><p><code>操作方法：使用winhex打开压缩文件，找到文件头第九第十个字符，将其修改为0000.</code></p><ol><li class="lvl-6"><p>使用winhex打开文件搜索16进制504B0102，可以看到每个加密文件头字段</p></li><li class="lvl-6"><p>从50开始计算，第九第十个字符为加密字段，将其设置为0000即为可变成无加密状态</p></li><li class="lvl-6"><p>RAR文件由于有头部校验，使用伪加密打开文件会出现报错，使用winhex修改标志位后如报错消失且正常解压缩，说明是伪加密。使用winhex打开RAR文件，找到第24个字节，该字节尾数为4表示加密，0表示无加密，将尾数改为0即可破解伪加密。</p></li></ol></li><li class="lvl-3"><p><strong>暴力破解</strong></p><p>通常可以使用ARCHPR.exe工具来破解zip文件</p><p><mark>使用场景：Windows下加密过的zip文件</mark></p><ol><li class="lvl-6"><p>攻击类型选择暴力破解，在范围位置根据提示选择暴力破解范围选项设置暴力破解包含的类型，开始于和结束于选项具体范围，如果没有定义则全范围暴力破解。</p><p><code>点击打开选择要破解的文件，点击开始进行破解。建议使用1~9位的数字密码，以及系统自带的英文字典作为密码字典</code></p></li><li class="lvl-6"><p>攻击类型选择掩码可以进行复杂的暴力破解，比如知道密码前3位是<mark>abc</mark>，后3位为数字，则在攻击类型选择掩码，在掩码处输入<mark>abc???</mark>，暴力范围选项选择所有数字，打开要破解的点击，点击破解。此时==???==的部分会被我们选择的暴力破解范围中字符代替。</p></li></ol></li><li class="lvl-3"><p><strong>明文攻击</strong></p><p>明文攻击指知道加密的ZIP中部分文件的明文内容，利用这些内容推测出密钥并解密ZIP文件方法，相比于暴力破解，这种方法在破解密码较为复杂的压缩包时效率更高。</p><p><mark>使用场景：已知加密的ZIP部分文件明文内容</mark></p><p>例：假设一个加密的压缩包中有两个文件readme.txt和flag.txt，其中flag.txt的内容是我们希望知道的内容，而我们拥有readme.txt的明文文件，使用上述两个文件即可进行明文攻击。</p><p><code>操作：</code></p><p><code>1、将readme.txt的明文文件进行压缩，变成readme1.zip</code></p><p><code>2、打开archpr，攻击类型选择明文，明文文件路径选择readme1.zip（即将明文文件不加密压缩后的文件），加密的文件</code></p><p><code>选择要破解的文件，点击开始，破解成功后会获得密码。</code></p><blockquote><p>使用该方法需要注意两个关键点：</p><p>1、有一个明文文件，压缩后CRC值与加密压缩包中的文件一致。</p><p>2、明文文件的压缩算法需要与加密压缩文件的压缩算法一致。</p></blockquote><p><strong>RAR文件格式</strong></p><p><mark>有时候给出的RAR文件的头部各个字块会会故意给错误导致无法识别。</mark></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302020003592.png" alt="RAR文件格式"></p></li></ol><h2 id="流量取证技术">流量取证技术</h2><p>CTF比赛中，<mark>流量包的取证分析</mark>是另一项重要的考察方向。</p><p>通常比赛中会提供一个包含流量数据的PCAP文件，有时候也会需要选手们先进行修复或重构传输文件后，再进行分析。</p><ul class="lvl-0"><li class="lvl-2"><p>总体把握</p><ul class="lvl-2"><li class="lvl-4">协议分级</li><li class="lvl-4">端点统计</li></ul></li><li class="lvl-2"><p>过滤筛选</p><ul class="lvl-2"><li class="lvl-4">过滤语法</li><li class="lvl-4">Host，Protocol，contains，特征值</li></ul></li><li class="lvl-2"><p>发现异常</p><ul class="lvl-2"><li class="lvl-4">特殊字符串</li><li class="lvl-4">协议某字符</li><li class="lvl-4">flag位于服务器中</li></ul></li><li class="lvl-2"><p>数据提取</p><ul class="lvl-2"><li class="lvl-4">字符串取</li><li class="lvl-4">文件提取</li></ul></li></ul><p><mark>总的来说比赛中的流量分析可以概括为以下三个方向：</mark></p><ul class="lvl-0"><li class="lvl-2"><p>流量包修复</p></li><li class="lvl-2"><p>协议分析</p></li><li class="lvl-2"><p>数据提取</p></li></ul><h3 id="流量数据包文件分析">流量数据包文件分析</h3><p><strong>WireShark工具的基本使用</strong></p><p>wirkshark的过滤器和过滤规则能够帮助我们迅速定位到要分析的报文。</p><p><mark>常用的过滤命令：</mark></p><ol><li class="lvl-3"><p>过滤IP，如源IP或者目标 x.x.x.x</p><p><code>ip.src eq x.x.x.x or ip.dst eq x.x.x.x 或者 ip.addr eq x.x.x.x</code></p></li><li class="lvl-3"><p>过滤端口</p><p><code>tcp.port eq 80 or udp.port eq 80</code></p><p><code>tcp.dstport == 80</code>    只显示tcp协议的目标端口为80</p><p><code>tcp.srcport == 80</code>    只显示tcp协议的源端口为80</p><p><code>tcp.port &gt;= 1 and tcp.port &lt;= 80</code></p></li></ol><p><strong>WireShark协议分析技巧：</strong></p><ol><li class="lvl-3"><p>查看网络协议：统计 -&gt; 协议分级</p></li><li class="lvl-3"><p>根据数据包特征进行筛选</p><p>右键 -&gt; 作为过滤器应用 -&gt; 选中</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202303072340671.png" alt=""></p></li><li class="lvl-3"><p>WireShark流汇聚</p><p>在关注的http数据包或tcp数据包中选择流汇聚，可以将HTTP流或TCP流汇聚或还原成数据，在弹出的框中可以看到数据内容。</p></li></ol><blockquote><p>常见的HTTP流关键内容：</p><ol><li class="lvl-3">HTML中直接包含重要信息</li><li class="lvl-3">上传或下载文件内容，通常包含文件名、hash值等关键信息，常用POST请求上传</li><li class="lvl-3">一句话木马，POST请求，内容包含eval，内容使用base64加密</li></ol></blockquote><p><strong>WireShark数据提取</strong></p><ol><li class="lvl-3"><p>使用WireShark可以自动提取通过http传输的文件内容</p><p><mark>文件 -&gt; 导出对象 -&gt; HTTP</mark></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202303111906811.png" alt=""></p></li><li class="lvl-3"><p>WireShark可以手动提取文件内容</p><p>点击想要的数据包，选定内容 的位置，右键 -&gt; 导出分组字节流，或者点击菜单栏 文件 -&gt; 导出分组字节流，快捷方式Ctrl + H，在弹出的框中将文件保存成二进制文件。</p></li></ol><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果自行承担，责任与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的排序算法(二)</title>
      <link href="/posts/a5e3.html"/>
      <url>/posts/a5e3.html</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序前传-树与二叉树">堆排序前传 - 树与二叉树</h2><h3 id="树">树</h3><ul class="lvl-0"><li class="lvl-2"><p>树是一种数据结构</p></li><li class="lvl-2"><p>树是一种可以递归定义的数据结构</p></li><li class="lvl-2"><p>树是由几个节点组成的集合</p><ul class="lvl-2"><li class="lvl-4">如果n=0，那这是一棵空树；</li><li class="lvl-4">如果n&gt;0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树。</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092044487.png" alt="树的数据结构"></p><ul class="lvl-0"><li class="lvl-2"><p>一些概念</p><ul class="lvl-2"><li class="lvl-4">根节点、叶子节点</li><li class="lvl-4">树的深度（高度）</li><li class="lvl-4">树的度</li><li class="lvl-4">孩子节点/父节点</li><li class="lvl-4">子树</li></ul></li></ul><h3 id="二叉树">二叉树</h3><ul class="lvl-0"><li class="lvl-2"><p>二叉树：度不超过2的树</p></li><li class="lvl-2"><p>每个节点最多有两个孩子节点</p></li><li class="lvl-2"><p>两个孩子节点被区分为左孩子节点和右孩子节点</p></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092100182.png" alt="二叉树的数据结构"></p><h3 id="完全二叉树">完全二叉树</h3><ul class="lvl-0"><li class="lvl-2"><p>满二叉树：一个二叉树，如果每个层的结点数都达到最大值，则这个二叉树就是满二叉树。</p></li><li class="lvl-2"><p>完全二叉树：叶节点只能出现在最下和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</p></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092105198.png" alt="完全二叉树的图示"></p><h3 id="二叉树的存储方式">二叉树的存储方式</h3><ul class="lvl-0"><li class="lvl-2"><p>二叉树的存储方式（表示方式）</p><ul class="lvl-2"><li class="lvl-4"><mark>链式存储方式</mark></li><li class="lvl-4"><mark>顺序存储方式</mark></li></ul></li></ul><h3 id="二叉树的顺序存储方式">二叉树的顺序存储方式</h3><p><mark>如图所示</mark></p><ul class="lvl-0"><li class="lvl-2"><p>父节点和左孩子节点的编号下标有什么关系？</p><ul class="lvl-2"><li class="lvl-4">0-1 1-3 2-5 3-7 4-9</li><li class="lvl-4">i-&gt;2i+1</li></ul></li><li class="lvl-2"><p>父节点和右孩子节点的编号下标有什么关系？</p><ul class="lvl-2"><li class="lvl-4">0-2 1-4 2-6 3-8 4-10</li><li class="lvl-4">i-&gt;2i+2</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092117768.png" alt="二叉树的顺序存储方式"></p><h2 id="堆排序">堆排序</h2><h3 id="什么是堆">什么是堆</h3><ul class="lvl-0"><li class="lvl-2"><p>堆：一种特殊的完全二叉树结构</p><ul class="lvl-2"><li class="lvl-4">大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li><li class="lvl-4">小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092129845.png" alt="大根堆和小根堆"></p><h3 id="堆的向下调整性质">堆的向下调整性质</h3><ul class="lvl-0"><li class="lvl-2"><p>假设根节点的左右子树都是堆，但根节点不满足堆的性质</p></li><li class="lvl-2"><p>可以通过一次向下的调整来将其变成一个堆</p></li></ul><h3 id="堆排序过程">堆排序过程</h3><ul class="lvl-0"><li class="lvl-2"><p>1.建立堆</p></li><li class="lvl-2"><p>2.得到堆顶元素，为最大元素</p></li><li class="lvl-2"><p>3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序</p></li><li class="lvl-2"><p>4.堆顶元素为第二大元素</p></li><li class="lvl-2"><p>5.重复步骤3，直到堆变空</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def sift(li,low,high):    # li：列表    # low：堆的根节点位置    # high：堆的最后一个元素的位置    i = low  # i最开始指向根节点    j = 2 * i + 1  # j开始是左孩子    tmp = li[low]  # 把堆顶存起来    while j &lt;= high:  # 只要j位置有数        if j + 1 &lt;= high and li[j+1] &gt; li[j]:  # 如果右孩子有并且比较大            j = j + 1  # j指向右孩子        if li[j] &gt; tmp:            li[i] = li[j]            i = j  # 往下看一层            j = 2 * i + 1        else:  # tmp更大，把tmp放到i的位置上            li[i] = tmp  # 把tmp放到某一级领导位置上            break    else:        li[i] = tmp  # 把tmp放到叶子节点上        def heap_sort(li):    n = len(li)    for i in range((n-2)//2,-1,-1):        # i表示建堆的时候调整的部分的根下标        sift(li,i,n-1)    # 建堆完成了    for i in range(n-1,-1,-1):        # i指向当前堆的最后一个元素        li[0], li[i] = li[i], li[0]        sift(li,0,i-1)  # i-1是新的high<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(nlogn)</p></li></ul><h3 id="内置模块">内置模块</h3><ul class="lvl-0"><li class="lvl-2"><p>python内置模块–heapq</p></li><li class="lvl-2"><p>常用函数</p><ul class="lvl-2"><li class="lvl-4">heapify(x)</li><li class="lvl-4">heappush(heap,item)</li><li class="lvl-4">heappop(heap)</li></ul></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import heapqimport randomli = list(range(100))random.shuffle(li)print(li)heapq.heapify(li)  # 建堆n = len(li)for i in range(n):    print(heapq.heappop(li),end=',')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="topk问题">topk问题</h3><ul class="lvl-0"><li class="lvl-2"><p>现在有n个数，设计算法得到前k大的数。（k&lt;n）</p></li><li class="lvl-2"><p>解决思路：</p><ul class="lvl-2"><li class="lvl-4">排序后切片      <mark>O(nlogn)</mark></li><li class="lvl-4">冒泡排序 选择排序 插入排序    <mark>O(mn)</mark></li><li class="lvl-4">堆排序思路   <mark>O(mlogn)</mark></li></ul></li></ul><blockquote><p>堆排序解决思路：</p><ul class="lvl-1"><li class="lvl-2">取列表前k个元素建立一个小根堆。堆顶就是目前第k大的数</li><li class="lvl-2">依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整</li><li class="lvl-2">遍历列表所有元素后，倒序弹出堆顶</li></ul></blockquote><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def sift(li,low,high):    # li：列表    # low：堆的根节点位置    # high：堆的最后一个元素的位置    i = low  # i最开始指向根节点    j = 2 * i + 1  # j开始是左孩子    tmp = li[low]  # 把堆顶存起来    while j &lt;= high:  # 只要j位置有数        if j + 1 &lt;= high and li[j+1] &lt; li[j]:              j = j + 1  # j指向右孩子        if li[j] &lt; tmp:            li[i] = li[j]            i = j  # 往下看一层            j = 2 * i + 1        else:  # tmp更大，把tmp放到i的位置上            li[i] = tmp  # 把tmp放到某一级领导位置上            break    else:        li[i] = tmp  # 把tmp放到叶子节点上        def topk(li,k):    heap = li[0:k]    for i in range((k-2)//2, -1, -1):        sift(heap,i,k-1)    # 1.建堆    for i in range(k,len(li)-1):        if li[i] &gt; heap[0]:            heap[0] = li[i]            sift(heap,0,k-1)    # 2.遍历    for i in range(k-1, -1, -1):        li[0], li[i] = li[i], li[0]        sift(li,0,i-1)    # 3.出数    return heap# 测试                   import randomli = list(range(1000))random.shuffle(li)print(topk(li,10))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的排序算法(一)</title>
      <link href="/posts/6547.html"/>
      <url>/posts/6547.html</url>
      
        <content type="html"><![CDATA[<h2 id="列表排序">列表排序</h2><ul class="lvl-0"><li class="lvl-2"><p>排序：将一组“无序”的记录序列调整为“有序”的记录序列</p></li><li class="lvl-2"><p>列表排序：将无序列表变为有序列表</p><ul class="lvl-2"><li class="lvl-4">输入：列表</li><li class="lvl-4">输出：有序列表</li></ul></li><li class="lvl-2"><p>升序与降序</p></li><li class="lvl-2"><p>内置排序函数：<mark>sort()</mark></p></li></ul><h2 id="冒泡排序-Bubble-Sort">冒泡排序(Bubble Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>列表每两个相邻的数，如果前面比后面大，则交换这两个数</p></li><li class="lvl-2"><p>一趟排序完成后，则无序区减少一个数，有序区增加一个数</p></li><li class="lvl-2"><p>代码关键点：趟、无序区范围</p></li></ul><p><strong>代码示例</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import randomdef bubble_sort(li):    for i in range(len(li)-1):  # 第i趟        for j in range(len(li)-i):            if li[j]&gt;li[j+1]:                li[j],li[j+1]=li[j+1],li[j]#验证li = [random.randint(0,10000) for i in range(1000)]print(li)bubble_sort(li)print(li)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(n<sup>2</sup>)</p></li></ul><p><mark>冒泡排序-优化</mark>：</p><ul class="lvl-0"><li class="lvl-2"><p>如果冒泡排序中的一趟排序没有发生交换，则说明列表已经有序，可以直接结束算法。</p></li></ul><p><strong>代码示例</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def bubble_sort(li):    for i in range(len(li)-1):        exchange = False        for j in range(len(li)-i-1):            if li[j] &gt; li[j+1]:                li[j], li[j+1] = li[j+1], li[j]                 exchange = True            if not exchange:                return<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(n<sup>2</sup>)</p></li></ul><h2 id="选择排序-Select-Sort">选择排序(Select Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>一趟排序记录最小的数，放到第一个位置</p></li><li class="lvl-2"><p>再一趟排序记录列表无序最小的数，放到第二个位置</p></li><li class="lvl-2"><p>…</p></li><li class="lvl-2"><p>算法关键点：有序和无序区、无序区最小数的位置</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def select_sort(li):    for i in range(len(li)-1):        min_loc = i        for j in range(i+1,len(li)):            if li[j] &lt; li[min_loc]:                min_loc = j        if min_loc != i:            li[i], li[min_loc] = li[min_loc], li[i]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入排序-Inset-Sort">插入排序(Inset Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>初始时手里（有序区）只有一张牌</p></li><li class="lvl-2"><p>每次（从无序区）摸一张牌，插入到手里已有牌的正确位置</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def insect_sort(li):    for i in range(1,len(li)):        tmp = li[i]        j = i - 1        while j &gt;= 0 and tmp &lt; li[j]:            li[j+1] = li[j]            j = j - 1         li[j+1] = tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(n<sup>2</sup>)</p></li></ul><h2 id="快速排序-Quick-Sort">快速排序(Quick Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>快速排序：<mark>快</mark></p></li><li class="lvl-2"><p>快速排序思路：</p><ul class="lvl-2"><li class="lvl-4">取一个元素p（第一个元素），使元素p归位；</li><li class="lvl-4">列表被p分成两部分，左边都比p小，右边都比p大；</li><li class="lvl-4">递归完成排序</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302062134346.png" alt=""></p><p><strong>快速排序-框架：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def quick_sort(data,left,right):    if left &lt; right:        mid = partition(data,left,right)        quick_sort(data,left,mid-1)        quick_sort(data,mid+1,right)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def partition(li,left,right):    tmp = li[left]    while left &lt; right:        while li[right] &gt;= tmp:  # 从右边找比tmp小的数            right -= 1  # 往左走一步        li[left] = li[right]  # 把右边的值写到左边空位上        while left &lt; right and li[left] &lt;= tmp:            left += 1        li[left] = tmp  # 把tmp归位        return leftdef quick_sort(li,left,right)    :    if left &lt; right:  # 至少两个元素        mid = partition(li,left,right)        quick_sort(li,left,mid-1)        quick_sort(li,mid+1,right)#调用测试li = [5,7,6,3,1,2,9,8]quick_sort(li,0,len(li)-1)print(li)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>快速排序的效率：</p><ul class="lvl-2"><li class="lvl-4">快速排序的时间复杂度：<mark>O(nlogn)</mark></li></ul></li><li class="lvl-2"><p>快速排序的问题</p><ul class="lvl-2"><li class="lvl-4"><p>最坏情况：</p><p>正序或逆序排列，二叉树画出来应该是一棵斜树，并且需要经过n-1次递归调用才能完成，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置，所以：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302091721179.png" alt=""></p><p>最终的时间复杂度应该O(n<sup>2</sup>)</p></li><li class="lvl-4"><p>递归：消耗一部分系统资源</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的排序算法(三)</title>
      <link href="/posts/3541.html"/>
      <url>/posts/3541.html</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序">归并排序</h2><h3 id="归并">归并</h3><ul class="lvl-0"><li class="lvl-2"><p>假设现在的列表分两段，如何将其合成一个有序列表</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302191523668.png" alt="归并排序"></p></li><li class="lvl-2"><p>这种操作称为一次归并</p></li></ul><h3 id="使用归并">使用归并</h3><ul class="lvl-0"><li class="lvl-2"><p>分解：将列表越分越小，直至分成一个元素</p></li><li class="lvl-2"><p>终止条件：一个元素是有序的</p></li><li class="lvl-2"><p>合并：将两个有序列表归并，列表越来越大</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def merge(li,low,high):    i = low    j = mid + 1    ltmp = []    while i&lt;mid and j&lt;=high:  # 只要左右两边都有数        if li[i] &lt; li[j]:            ltmp.append(li[i])            i += 1        else:            ltmp.append(li[j])            j += 1    # while执行完，肯定有一部分没数了    while i &lt;= mid:        ltmp.append(li[i])        i += 1    while j &lt;= high:        ltmp.append(li[i])        j += 1    li[low:high+1] = ltmp            def merge_sort(li,low,hight):    if low &lt; high:  # 至少有两个元素，递归        mid = (low + high) // 2        merge_sort(li,low,mid)        merge_sort(li,mid+1,high)        merge(li,low,mid,high)        #测试li = list(range(1000))import randomrandom.shuffle(li)print(li)merge_sort(li,0,len(li)-1)print(li)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>时间复杂度：O(nlogn)</mark></p></li><li class="lvl-2"><p>空间复杂度：O(n)</p></li></ul><h2 id="小结">小结</h2><ul class="lvl-0"><li class="lvl-2"><p>三种排序算法的时间复杂度都是O(nlogn)</p></li><li class="lvl-2"><p>一般情况下，就运行时间而言：</p><ul class="lvl-2"><li class="lvl-4">快速排序 &lt; 归并排序 &lt; 堆排序</li></ul></li><li class="lvl-2"><p>三种排序算法的缺点：</p><ul class="lvl-2"><li class="lvl-4">快速排序：极端情况下排序效率低</li><li class="lvl-4">归并排序：需要额外的内存开销</li><li class="lvl-4">堆排序：在快的排序算法中相对较慢</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302191554786.png" alt="小结"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的列表查找</title>
      <link href="/posts/4c50.html"/>
      <url>/posts/4c50.html</url>
      
        <content type="html"><![CDATA[<h2 id="查找">查找</h2><ul class="lvl-0"><li class="lvl-2"><p>查找：在一些数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程</p></li><li class="lvl-2"><p>列表查找（线性表查找）：从列表中查找指定元素</p><ul class="lvl-2"><li class="lvl-4">输入：列表、待查找元素</li><li class="lvl-4">输出：元素下标（未找到元素时一般返回None或-1）</li></ul></li><li class="lvl-2"><p>内置列表查找函数：index()</p></li></ul><h2 id="顺序查找-Linear-Search">顺序查找(Linear Search)</h2><ul class="lvl-0"><li class="lvl-2"><p>顺序查找：也叫线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止</p></li><li class="lvl-2"><p>时间复杂度：O(n)</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def linear_search(li,val):    for ind ,v in emumerate(li):        if v == val:            return ind        else:            return None#或者def linear_search(data_set,value):    for i in range(range(data_set)):        if data_set[i] == value:            return i     return <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二分查找-Binar-Search">二分查找(Binar Search)</h2><ul class="lvl-0"><li class="lvl-2"><p>二分查找：又叫折半查找，从有序列表的初始候选区 li[0:n] 开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def binary_search(li,val):   # val：元素    left = 0    right = len(li) - 1    while left &lt;= right:# 候选区有值        mid = (left + right)// 2        if li[mid] == val:            return mid        elif li[mid] &gt; val: # 带查找的值在mid左侧            right = mid -1        else:   # li[mid] &lt; val 带查找的值在mid右侧            left = mid + 1      else:             return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(logn)</p></li></ul><p><mark>测试运行时间代码</mark>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timedef cal_time(func):    def wrapper(*args,**kwargs):        t1 = time.time()        result = func(*args,**kwargs)        t2 = time.time()        print("%s running time: %s secs." % (func.__name__,t2-t1))        return result    return wrapper# 运用时，先导入这个模块，再用@cal_time语句放在函数代码，如：@cal_timedef binary_search(li,val):   # val：元素    left = 0    right = len(li) - 1    while left &lt;= right:# 候选区有值        mid = (left + right)// 2        if li[mid] == val:            return midcal_time        elif li[mid] &gt; val: # 带查找的值在mid左侧            right = mid -1        else:   # li[mid] &lt; val 带查找的值在mid右侧            left = mid + 1      else:             return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：内置函数 index() 用的是线性查找。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<h2 id="谈谈博客对我的影响">谈谈博客对我的影响</h2><p>本人是一名在读大三的学生，这是我写的第一篇博客文章，经过一番折腾后，虽然中间有点小插曲，但是我还是顺利地完成好搭建这个属于我个人的博客，作为一名长期以自学为主的人来说，我的知识的积累和技术的成长很大程度都离不开博客，先是因为学校无法提供偏技术这方面的培养，我便开始了一段独立且漫长的自学历程，由于我是web安全为主要方向学习，在我个人自学和结合靶场训练的过程，遇到问题也常有的事情，很多时候就去网上查资料学习，这时候我一般去阅读别人的博客文章，看别人是怎么解决问题，思路是怎么样的，涉及那些具体的知识点，我都比较地阅读。慢慢地，就会有一定的知识的积累和对问题解决的方法，当然，像技能的提升种肯定是离不开稳扎稳打的训练。我非常感谢别人的对自己个人知识和技术的分享，以及一些问题的解决，写成博客文章，供大家学习，这种分享的精神，我觉得是非常宝贵和伟大的，想必大多数计算机相关的学习者和我都一样，博客对我们的知识的积累和技术的成长有一定的影响的。</p><h2 id="希望自己也能成为影响他人的人">希望自己也能成为影响他人的人</h2><p>由于自己在学习的过程中有经常记笔记的习惯，并且积累了一定个人自学笔记，我也希望自己写出一些博客文章，供大家作学习参考，这是我个人搭建博客的想法和初衷，如果你觉得我的博客文章写得不错，或者某部分细节能解决你手上棘手的问题的话，你也可以关注一下我的博客，我会尽个人所能写好每一篇博客文章，原创不易，也非常期待你的小赏喔。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>misc的基本解题思路(一)</title>
      <link href="/posts/b478.html"/>
      <url>/posts/b478.html</url>
      
        <content type="html"><![CDATA[<p><strong>misc的四大部分：</strong></p><ul class="lvl-0"><li class="lvl-2">文件操作与隐写</li><li class="lvl-2">图片隐写术</li><li class="lvl-2">压缩文件处理</li><li class="lvl-2">流量取证技术</li></ul><h2 id="文件操作与隐写">文件操作与隐写</h2><h3 id="文件类型识别">文件类型识别</h3><ol><li class="lvl-3"><p>File命令</p><p>当文件没有后缀名或者有后缀名而无法打开时，根据识别出的文件类型来修改后缀名即可正常打开文件。</p><p><mark>使用场景：不知道后缀名，无法打开文件</mark></p><p><code>Linux环境下命令格式：file+文件名</code></p></li><li class="lvl-3"><p>winhex</p><p>通过<mark>winhex</mark>程序中可以查看文件头类型，根据头类型判断文件类型</p><p><mark>使用场景：windows下通过文件头信息判断文件类型</mark></p></li></ol><p><strong>常见的文件头类型如下：</strong></p><table><thead><tr><th>文件类型</th><th>文件头</th></tr></thead><tbody><tr><td>JPEG(jpg)</td><td>FFD8FFE1</td></tr><tr><td>PNG(png)</td><td>89504E47</td></tr><tr><td>GIF(gif)</td><td>47494638</td></tr><tr><td>TIFF(tiff)</td><td>49492A00</td></tr><tr><td>Windows Bitmap(bmp)</td><td>424DC001</td></tr><tr><td>ZIP Archive(ZIP)</td><td>504B0304</td></tr><tr><td>RAR Archive(rar)</td><td>52617221</td></tr><tr><td>Adobe Photshop(psd)</td><td>38425053</td></tr><tr><td>Rich Text Format(rtf)</td><td>7B5C727466</td></tr><tr><td>XML(xml)</td><td>3C3F786D6C</td></tr><tr><td>HTML(html)</td><td>68746D6C3E</td></tr><tr><td>Adobe Acrobat(pdf)</td><td>255044462D312E</td></tr><tr><td>Wave(wav)</td><td>57415645</td></tr><tr><td>pacp</td><td>4D3C2B1A</td></tr></tbody></table><ol start="3"><li class="lvl-3"><p>文件头残缺/错误</p><p>通常文件无法正常打开有两种情况，一种文件头部残缺，另一种头部字段错误。针对文件头部残缺的情况，使用winhex程序添加相应的文件头，针对头部字段错误，可以找一个相同类型的文件进行替换。</p><p><mark>使用场景：文件头部残缺或文件头部字段错误无法打开正常文件</mark></p><p><code>格式：file 文件名</code></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011320661.png" alt=""></p></li></ol><h3 id="文件分离操作">文件分离操作</h3><ol><li class="lvl-3"><p><strong>Binwalk工具</strong></p><p><strong>Binwalk</strong>工具是Linux下用来分析和分离文件的工具，可以快速分辨文件是否由多个文件合并而成，并将文件进行分离。如果分离成功会在目标文件的目录。</p><p>同目录下生成一个形如_文件名_extracted的文件目录，目录中有分离后的文件。</p><p><mark>用法</mark>：</p><p><code>分析文件：binwalk filename</code></p><p><code>分离文件：binwalk -e filename</code></p><blockquote><p>注：binwalk遇到压缩包会自动解压。</p></blockquote></li><li class="lvl-3"><p><strong>formost</strong></p><p>如果<strong>binwalk</strong>无法正确分离文件，可以使用<strong>foremost</strong>，将目标文件复制到kali中，成功执行后，会在目标文件的文件目录下生成我们设置的目录，目录中会按文件类型分离出文件。</p><p><mark>用法</mark>：</p><p><code>foremost 文件名 -o 输出目录名</code></p></li><li class="lvl-3"><p><strong>dd</strong></p><p>当文件自动分离出错或者因为其他原因无法自动分离时，可以使用<strong>dd</strong>实现文件手动分离。</p><p><code>格式：dd if=源文件 of=目标文件名 bs=1 skip=开始分离的字节数</code></p><p><mark>参数说明</mark>：</p><p><code>if=file  #输入文件名，缺省为标准输入</code></p><p><code>of=file  #输出文件名，缺省为标准输出</code></p><p><code>bs=bytes  #同时设置读写块的大小为bytes，可代替ibs和obs</code></p><p><code>skip=blocks  #从输入文件开头跳过blocks个块后再开始复制</code></p></li><li class="lvl-3"><p><strong>Winhex</strong></p><p>除了使用dd外，还可以使用winhex实现文件手动分离，将目标文件拖入问winhex中，找到要分离的部分，点击复制即可。</p><p><mark>使用场景：Windows下利用winhex程序对文件进行手动分离</mark></p></li><li class="lvl-3"><p><strong>010Editor</strong></p><p><mark>将某块区域文件保存的方式如下：</mark></p><ol><li class="lvl-6"><p>010Editor打开文件 -&gt; 选中右键 -&gt; Selection -&gt; Save Selection</p></li></ol><p><mark>将16进制字符文件导入保存操作方法如下：</mark></p><ol><li class="lvl-6"><p>将16进制字符文件保存在一个文件</p></li><li class="lvl-6"><p>打开010Editor import Hex</p></li><li class="lvl-6"><p>另存为一个文件，后缀名以010Editor获取到它本身文件信息而定</p></li></ol></li></ol><h3 id="文件合并操作">文件合并操作</h3><ol><li class="lvl-3"><p><strong>Linux下的文件合并</strong></p><p><mark>使用场景：Linux下，通常对文件名相似的文件要进行批量合并</mark></p><p><code>格式：cat 合并的文件 &gt; 输出的文件</code></p><p><mark>完整性检测：Linux下计算文件md5：</mark></p><p><code>md5sum 文件名</code></p></li><li class="lvl-3"><p><strong>Windows下的文件合并</strong></p><p><mark>使用场景：Windows下，通常要对文件 名相似的文件进行批量合并</mark></p><p><code>格式：copy /B 合并的文件 输出的文件命令</code></p><p><mark>完整性检测：Windows下计算文件md5：</mark></p><p><code>certutil -hashfiel 文件名 md5</code></p></li></ol><h3 id="文件内容隐写">文件内容隐写</h3><p>文件内容隐写，就是直接将KEY以十六进制的形式写在文件中，通常在文件的开头或结尾部分，<mark>分析时通常重点观察文件开头和结尾部分</mark>。如果在文件中间部分，通常搜索关键字<strong>KEY</strong>或者<strong>flag</strong>来查找隐藏内容。</p><p><mark>使用场景：Windows下，搜索隐写的文件内容</mark></p><ol><li class="lvl-3"><p>winhex/010Editor</p><p>通常将识别的文件拖入<strong>winhex</strong>中，查找具有关键字或明显与文件不和谐的部分，通常优先观察文件首部和尾部，搜索flag或key等关键字，最后拖动滚轮寻找。</p></li><li class="lvl-3"><p>Notepad++</p><p>使用<strong>Notepad++<strong>打开文件，查看文件头尾是否有含有关键字的字符串，搜索</strong>flag</strong>或<strong>key</strong>等关键字，最后拖动滚轮寻找。</p><p>另外通过安装插件HEX-Editor可以实现winhex的功能</p></li></ol><h2 id="图片隐写术">图片隐写术</h2><h3 id="图片隐写的常见隐写方法">图片隐写的常见隐写方法</h3><ol><li class="lvl-3"><p><strong>细微的颜色差别</strong></p></li><li class="lvl-3"><p><strong>GIF图多帧隐藏</strong></p><ol><li class="lvl-6">颜色通道隐藏</li><li class="lvl-6">不同帧图信息隐藏</li><li class="lvl-6">不同帧对比隐写</li></ol></li><li class="lvl-3"><p><strong>Exif信息隐藏</strong></p></li><li class="lvl-3"><p><strong>图片修复</strong></p><ol><li class="lvl-6">图片头修复</li><li class="lvl-6">图片尾修复</li><li class="lvl-6">CRC校验修复</li><li class="lvl-6">长、宽、高度修复</li></ol></li><li class="lvl-3"><p><strong>最低有效位LSB隐写</strong></p></li><li class="lvl-3"><p><strong>图片加密</strong></p><ol><li class="lvl-6">Stedetect</li><li class="lvl-6">outguess</li><li class="lvl-6">F5</li></ol></li></ol><h3 id="图片文件隐写">图片文件隐写</h3><ol><li class="lvl-3"><p><strong>Firework</strong></p><p>使用<strong>winhex</strong>打开文件时会看到文件头部中包含f<strong>irework</strong>的标识，通过<strong>firework</strong>可以找到隐藏图片。</p><p><mark>使用场景：查看隐写的图片文件</mark></p></li><li class="lvl-3"><p><strong>Exif</strong></p><p><strong>Exif</strong>按照JPEG的规格在JPEG中插入一些图像/数字相机的信息数据以及缩略图像，可以通过与JPEG兼容的互联浏览器/图片浏览器/图片处理等一些软件来查看<strong>Exif</strong>格式的图片文件，就跟浏览器通常JPEG图像文件一样。</p><p>图片右键属性，查看Exif或查看详细信息，在相关选项卡中看找flag信息。</p><p>如果是Linux环境下，可以用<strong>exiftool</strong>工具，<code>命令：exiftool 文件名（带后缀名）</code></p></li><li class="lvl-3"><p><strong>Stegsolve</strong></p><p>当两张图片外观、大小、像素都基本相同时，可以考虑进行结合分析，即将两个文件的像素RGB值进行XOR、ADD、SUB等操作，看能否得到有用的信息，Stegsolve可以方便地进行这些操作。</p><p><mark>使用场景：两张图片信息基本相同</mark></p><ol><li class="lvl-6"><p>打开第一张图片，点击analyse -&gt; Image combiner</p></li><li class="lvl-6"><p>在弹出的窗口中点击左右按钮选择处理方式，点击save保存有价值的结果</p></li></ol></li><li class="lvl-3"><p><strong>LSB（最低有效位Least Significant Bit)</strong></p><p><strong>LSB</strong>替换隐写基本思想是用嵌入的秘密信息取代载体图像的最低特位，原来的7个高位平面与替代秘密信息的最低位平面组合成含有隐藏信息的新图形。</p><ol><li class="lvl-6"><p>像素三原色（RGB）</p></li><li class="lvl-6"><p>通过修改像素中最低位的1bit来达到隐藏的效果</p></li><li class="lvl-6"><p>工具：stegsolve、zsteg、wbstego4、python脚本</p></li><li class="lvl-6"><p><strong>Stegsolve.jar工具</strong></p><ol><li class="lvl-9">打开文件 -&gt; Analyse -&gt; Data Extract</li><li class="lvl-9">调整Bit Plans，Bits Order，Bit Plane Order</li></ol></li><li class="lvl-6"><p><strong>zsteg工具</strong></p><p><mark>检测LSB隐写：</mark></p><p><code>命令：zsteg xxx.png</code></p></li><li class="lvl-6"><p><strong>wbstego4工具</strong></p><p>解密通过1sb加密的图片</p></li><li class="lvl-6"><p><strong>python脚本来处理</strong></p><p>将目标文件放在以下脚本目录下，将脚本中的文件名修改为你的目标文件名，运行python脚本即可</p><blockquote><p>注：要在python2的环境运行。</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">#coding:utf-8import PIL.Imagedef foo():    im = PIL.Image.open('01.bmp')  #将'01.bmp'修改为你的目标文件名     im2 = im.copy()    pix = im2.load()    width,height = im2.size        for x in xrange(0,width):        for y in xrange(0,height):            if pix[x.y]&amp;0x1 == 0:                pix[x,y] = 0            else:                pix[x,y] = 255    im2.show()    passif __name__=='__main__':    foo()    print 'ok.'    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li class="lvl-3"><p>TTweakPNG</p><p><strong>TweakPNG</strong>是一款简单易用的PNG图像浏览工具，它允许查看和修改一些PNG图像文件的元信息存储。</p><p><mark>使用场景：文件头正常却无法打开文件，利用TweakPNG修CRC</mark></p><p>例：</p><ol><li class="lvl-6"><p>当PNG文件头正常但无法打开文件，可能是CRC校验出错，可以尝试通过TweakPNG打开PNG，会弹出校验错误的提示，这里显示CRC是fe1a5ab6，正确的是b0a7a9f1。打开winhex搜索fe1a5ab6将其改为b0a7a9f1</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011629751.png" alt=""></p></li></ol><p><mark>有时CRC没有错误，但是图片的高度或者宽度发生了错误，需要通过CRC计算出正确的高度或者宽度。</mark></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011652177.png" alt=""></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#cooding:utf-8import binasciiimport structcrcbp = open("xxx.png","rb").read()  # 此处将'xxx.png'改成你的目标文件名for i in range(1024):    for j in range(1024):        data = crcbp[12:16]+struct.pack('&gt;i',i)+struct.pack('&gt;i',j)+crcbp[24:29]        crc32 = binascii.crc32(data)&amp;0xffffffff        if crc32 == 0x08ec7edb:  # 此处填上CRC值            print i,j            print "hex".hex(i),hex(j)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li class="lvl-3"><p><strong>Bftools</strong></p><p><strong>bftools</strong>用于解密图片信息</p><p><mark>使用场景：在Windows的cmd下，对加密过的图片文件进行解密</mark></p><p><code>格式：Bftools.exe decode braincopter 要解密的图片名称 -output 输出文件名</code></p><p><code>Bftools.exe run 上一步输出的文件</code></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011703200.png" alt=""></p></li><li class="lvl-3"><p><strong>SilentEye</strong></p><p><strong>silenteye</strong>是一款可以将文字或者文件隐藏到图片的解密工具。</p><p><mark>使用场景：Windows下打开silentEye工具，对加密的图片进行解密</mark></p><p>例：</p><ol><li class="lvl-6"><p>使用silentEye程序打开目标图片，点击image -&gt; decode，点击decode，可以查看隐藏文件，点击保存即可</p></li></ol></li><li class="lvl-3"><p>JPG图像加密</p><ol><li class="lvl-6"><p><strong>Stegdetect</strong>工具探测加密方式</p><blockquote><p>Stegdetect程序主要用于分析JPEG文件。因此用Stegdetect可以检测到通过JSteg、JPHide、OutGuess、Invisble Secrets、F5、appendx和Camoutflage等这些隐写工具隐藏的信息。</p></blockquote><p><code>Linux环境下命令：</code></p><p><code>stegdetect xxx,jpg</code></p><p><code>stegdetect -s 敏感度 xxx.jpgexi</code></p></li><li class="lvl-6"><p><strong>Jphide</strong></p><p><strong>Jphide</strong>是基于最低有效位LSB的JPEG格式图像隐写算法。</p><p>例：</p><p>Stegdetect提示jphide加密时，可以用Jphs工具进行解密，打开jphswin.exe，使用open jpeg打开图片，点击seek，输入密码和确认密码，在弹出文件框中选择要保存的解密文件位置即可，结果保存成txt文件。</p></li><li class="lvl-6"><p><strong>Outguess</strong></p><p><strong>Outguess</strong>一般用于解密文件信息</p><p><mark>使用场景：Stegdetect识别出来或者题目提示时outguess加密的图片</mark></p><p><code>格式：outguess -r 要解密的文件名输出结果文件名</code></p></li><li class="lvl-6"><p><strong>F5</strong></p><p><strong>F5</strong>一般用于解密文件信息</p><p><mark>使用场景：Stegdetect识别出来是F5加密的图片或题目提示是F5加密的图片</mark></p><p>进入F5-steganography_F5目录，将图片文件拷贝至该目录下，从CMD进入该目录</p><p><code>格式：Java Exrtact 要解密的文件名 -p 密码</code></p></li></ol></li><li class="lvl-3"><p><strong>二维码处理</strong></p><ol><li class="lvl-6">使用二维码扫描工具CQR.exe打开图片，找到内容字段</li><li class="lvl-6">如果二维码某个定位角被覆盖了，该工具有时候也可以自动识别，如果识别失败，需要使用PS或画图工具将另外几个角的定位符移动到相应的位置，补全二维码。</li><li class="lvl-6">如果某个二维码的定位点中间是白色，可能被反色了，使用画图工具把颜色反色回来再扫描即可。</li></ol></li></ol><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果自行承担，责任与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据类型</title>
      <link href="/posts/bb2d.html"/>
      <url>/posts/bb2d.html</url>
      
        <content type="html"><![CDATA[<h2 id="python数据类型概况">python数据类型概况</h2><p><strong>数字类型</strong></p><p><strong>字符类型</strong></p><p><strong>布尔类型</strong></p><p><strong>空类型</strong></p><p><strong>列表类型</strong></p><p><strong>元组类型</strong></p><p><strong>字典类型</strong></p><h3 id="整型int">整型int</h3><ul class="lvl-0"><li class="lvl-2"><p>整型就是所说的整数，0也是整数，但是特殊的整数</p></li><li class="lvl-2"><p><mark>int</mark>即是整型的代表，又是定义整型的<mark>内置函数</mark></p></li></ul><h3 id="浮点型">浮点型</h3><ul class="lvl-0"><li class="lvl-2"><p>浮点型就是我们生活中的小数，凡是带有小数点的类型，都可以认为是浮点型</p></li><li class="lvl-2"><p>在python中，<mark>float</mark>既是浮点型的代表，又是浮点型类型定义的内置函数</p></li><li class="lvl-2"><p>定义<mark>float</mark>类型的时候，并不需要一定使用<mark>float</mark>声明</p></li></ul><h3 id="内置函数–type">内置函数–type</h3><ul class="lvl-0"><li class="lvl-2"><p>返回变量的类型</p></li><li class="lvl-2"><p><mark>type</mark>（已经被赋值的变量名或变量）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">count = 1050print(type(count))print(type(3.1415926))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="字符串">字符串</h3><ul class="lvl-0"><li class="lvl-2"><p>用 " 或者 “” 包裹的信息，就是字符串</p></li><li class="lvl-2"><p>字符串中可以包含任意字符：如字母，数字，符号，且没有先后顺序</p></li></ul><h4 id="字符串的定义方法">字符串的定义方法</h4><p>在python中，使用<mark>str</mark>来代表字符串类型，并且通过该函数可以定义字符串</p><h4 id="字符串的重要思想">字符串的重要思想</h4><ul class="lvl-0"><li class="lvl-2"><p>字符串是不可改变的！</p></li></ul><h4 id="内置函数id">内置函数id</h4><ul class="lvl-0"><li class="lvl-2"><p>返回变量的内存地址</p></li><li class="lvl-2"><p>数字地址 = <mark>id</mark>(变量)</p></li></ul><h4 id="内置函数">内置函数</h4><ul class="lvl-0"><li class="lvl-2"><p>返回字符串的长度</p></li><li class="lvl-2"><p>无法返回数字类型的长度，因为数字类型没有长度</p></li><li class="lvl-2"><p>返回 = len(字符串)</p></li></ul><h4 id="内置成员运算符in的使用">内置成员运算符<mark>in</mark>的使用</h4><ul class="lvl-0"><li class="lvl-2"><p>成员运算符是用来判断你的数据中是否存在你想要的成员</p></li></ul><h4 id="内置函数max">内置函数<mark>max</mark></h4><ul class="lvl-0"><li class="lvl-2"><p><mark>max</mark>(数据) -&gt; 成员值     <code>print(max(''今天是1月3日!'))</code>    -&gt; <mark>月</mark></p></li><li class="lvl-2"><p><strong>规则</strong>：中文符号 &gt; 字母 &gt; 数字 &gt; 英文符号</p></li><li class="lvl-2"><p>中文按照拼音的首字母来计算</p></li></ul><h4 id="内置函数min">内置函数<mark>min</mark></h4><ul class="lvl-0"><li class="lvl-2"><p><mark>min</mark>函数返回数据中最小的成员  <code>pinrt(min('今天是1月3日!'))</code>  -&gt; !</p></li><li class="lvl-2"><p>min(数据) &gt; 字母 &gt; 数字 &gt; 英文符号</p></li><li class="lvl-2"><p><strong>规则</strong>：中文符号 &gt; 字母 &gt; 数字 &gt; 英文符号</p></li><li class="lvl-2"><p>中文按照拼音的首字母来计算</p></li></ul><h4 id="字符串的累加">字符串的累加</h4><ul class="lvl-0"><li class="lvl-2"><p>字符串不是数字不能做减法，乘除法</p></li><li class="lvl-2"><p>字符串的拼接，用 “+” 这个符号</p></li></ul><h3 id="布尔类型">布尔类型</h3><ul class="lvl-0"><li class="lvl-2"><p>定义：真假的判断 即 布尔类型</p></li><li class="lvl-2"><p>固定值：True -&gt; 真；False -&gt; 假；</p></li><li class="lvl-2"><p>布尔值</p></li></ul><h4 id="布尔类型的使用">布尔类型的使用</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>bool</mark>代表布尔类型，也可以对于结果进行真假的判读</p></li></ul><h4 id="使用场景">使用场景</h4><ul class="lvl-0"><li class="lvl-2"><p>常被用来判断一件事儿的真假</p></li></ul><h4 id="数字与字符串的布尔应用">数字与字符串的布尔应用</h4><ul class="lvl-0"><li class="lvl-2"><p>int 0 -&gt; False，非0 -&gt; True</p></li><li class="lvl-2"><p>float 0.0 -&gt; False，非0.0 -&gt; True</p></li><li class="lvl-2"><p>str " -&gt; False(即 空字符串)，非空字符串 -&gt; True</p></li><li class="lvl-2"><p>在计算机中0 1是计算机的最原始形态，单个占空间也最小，故而经常会将0 1用来替代True与False</p></li></ul><h3 id="pyhton中的空类型">pyhton中的空类型</h3><ul class="lvl-0"><li class="lvl-2"><p>不属于任何数据类型就是<mark>空类型</mark></p></li><li class="lvl-2"><p>固定值：<mark>None</mark></p></li><li class="lvl-2"><p>空类型 属于 <mark>False</mark>的范畴</p></li><li class="lvl-2"><p>如果不确定类型的时候可以使用<mark>空类型</mark></p></li></ul><h3 id="列表类型">列表类型</h3><ul class="lvl-0"><li class="lvl-2"><p>列表就是队列</p></li><li class="lvl-3"><p>他是各种数据类型的集合，也是一种数据结构</p></li><li class="lvl-2"><p>列表是一种有序，且内容可重复的集合类型</p></li></ul><h4 id="列表的定义">列表的定义</h4><ul class="lvl-0"><li class="lvl-2"><p>在python中，<mark>list</mark>代表这种类型，也可以用它定义一个列表  <code>name_01=list(['',''])</code></p></li><li class="lvl-2"><p>在python中，列表中的元素存在于一个[]中  <code>name_02=['','']</code></p></li><li class="lvl-2"><p>在python中，列表是一个无限制长度的数据结构</p></li></ul><h4 id="列表中的类型">列表中的类型</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>str_array</strong></p></li><li class="lvl-2"><p><strong>int_array</strong></p></li><li class="lvl-2"><p><strong>float_array</strong></p></li><li class="lvl-2"><p><strong>bool_array</strong></p></li><li class="lvl-2"><p><strong>list_array</strong>  列表中嵌套列表</p></li><li class="lvl-2"><p><strong>min_array</strong>  列表中可以放混合类型</p></li></ul><h4 id="in，max，min在列表中的使用">in，max，min在列表中的使用</h4><ul class="lvl-0"><li class="lvl-2"><p>1 in [1,2,3,4] -&gt; True; 10 in  [1,2,3,4] -&gt; False</p></li><li class="lvl-2"><p>max([1,2,3,4]) -&gt; 4</p></li><li class="lvl-2"><p>min([1,2,3,4]) -&gt; 1</p></li><li class="lvl-2"><p>max和min在列表中使用的时候，列表中的元素不能是多种类型，如果类型不统一，则会报错</p></li></ul><h3 id="元组">元组</h3><ul class="lvl-0"><li class="lvl-2"><p>元组和列表一样，都是一种可以存储多种数据结构的队列</p></li><li class="lvl-2"><p>元组也是一个有序的，且元素可以重复的集合</p></li></ul><h4 id="元组的定义">元组的定义</h4><ul class="lvl-0"><li class="lvl-2"><p>在python中，tuple代表着元组这种类型，也可以用它定义一个元组   <code>name_01=tuple('','')</code></p></li><li class="lvl-2"><p>在python中，元组中的元素存在于一个（）小括号中  <code>name_02=('','')</code></p></li><li class="lvl-2"><p>在python中，元组是一个无限制长度的数据结构</p></li></ul><blockquote><p>注：如果元组中只有一个元素，那一定要在这个元素后面加上一个逗号</p></blockquote><h4 id="列表与元组的区别">列表与元组的区别</h4><ul class="lvl-0"><li class="lvl-2"><p>元组比列表占用资源更小</p></li><li class="lvl-2"><p>列表是可变的，元组是不可变的</p></li></ul><h4 id="元组中的类型">元组中的类型</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>str_tuple</strong></p></li><li class="lvl-2"><p><strong>int_tuple</strong></p></li><li class="lvl-2"><p><strong>float_tuple</strong></p></li><li class="lvl-2"><p><strong>bool_tuple</strong></p></li><li class="lvl-2"><p><strong>none_tuple</strong>=(None,None,None)</p></li><li class="lvl-2"><p><strong>tuple_tuple</strong>=((1,2,3),(1.2,3.1))</p></li><li class="lvl-2"><p><strong>list_type</strong>=([123,456],[6789,1234])</p></li><li class="lvl-2"><p><strong>mix_tuple</strong>=(‘’,1,3.14,None,True)</p></li><li class="lvl-2"><p><strong>tuple_array</strong>=[(‘a’,‘b’),(‘c’,‘d’),(‘e’,)]</p></li></ul><h4 id="in，max，min在元组中的使用">in，max，min在元组中的使用</h4><ul class="lvl-0"><li class="lvl-2"><p>1 in （1，2，3，4） -&gt; True；10 not in （1，2，3，4） -&gt; True</p></li><li class="lvl-2"><p>max((1,2,3,4)) -&gt; 4</p></li><li class="lvl-2"><p>min((1,2,3,4)) -&gt; 1</p></li><li class="lvl-2"><p>max和min在元组中使用的时候，元组中的元素不能是多种类型，如果类型不统一，则会报错</p></li></ul><h3 id="字典类型">字典类型</h3><ul class="lvl-0"><li class="lvl-2"><p>字典是由多个键（key）及其对应的值（value）所组成的一种数据类型</p></li></ul><h4 id="字典的结构与创建方法">字典的结构与创建方法</h4><ul class="lvl-0"><li class="lvl-2"><p>在python中，<mark>dict</mark>用来代表字典，并且可以创建一个字典</p></li><li class="lvl-2"><p>在python中，通过{}将一个个key与value存入字典中</p><p><code>a = dict()</code></p><p><code>a = {}</code></p><p><code>person = {'name':'xiaoming','age':33}</code></p></li></ul><h4 id="字典支持的数据类型">字典支持的数据类型</h4><ul class="lvl-0"><li class="lvl-2"><p>key支持字符串，数字和元组类型，但列表是不支持的</p></li><li class="lvl-2"><p>value支持所有python的数据类型</p><p><code>a = {'name':'dewei','age':30}</code></p><p><code>b = {1:'one',2:'two'}</code></p><p><code>c = {(1,2,3):[1,2,3],(4,5,6):[4,5,6]}</code></p></li></ul><h4 id="列表与元组中的字典">列表与元组中的字典</h4><ul class="lvl-0"><li class="lvl-2"><p>dict_array = [{1:1,2:2},{‘one’:1,‘two’:2}]</p></li><li class="lvl-2"><p>dict_tuple = ({1:1,2:2},{‘one’:1,"two’:2})</p></li><li class="lvl-2"><p><mark>元组一旦创建，就不可以改变</mark></p></li></ul><h4 id="python3-7与之前版本-字典的区别">python3.7与之前版本 字典的区别</h4><ul class="lvl-0"><li class="lvl-2"><p>python3.7之前是无序的</p></li><li class="lvl-2"><p>python3.7之后是有序的</p></li></ul><h4 id="字典的重要特性">字典的重要特性</h4><ul class="lvl-0"><li class="lvl-2"><p>字典中每一个key一定是唯一的</p></li></ul><h3 id="数字的运算">数字的运算</h3><h4 id="赋值运算符">赋值运算符</h4><table><thead><tr><th>运算符</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>=</td><td>等于运算符</td><td>c=a+b</td></tr><tr><td>+=</td><td>加法运算符</td><td>c+=a -&gt; c=c+a</td></tr><tr><td>-=</td><td>减法运算符</td><td>c-=a -&gt; c=c-a</td></tr><tr><td>*=</td><td>乘法运算符</td><td>c*=a  -&gt;  c=c * a</td></tr><tr><td>/=</td><td>除法运算符</td><td>c/=a -&gt; c=c/a</td></tr><tr><td>%=</td><td>取模运算符</td><td>c%=a -&gt; c=c%a</td></tr><tr><td>**=</td><td>幂运算符</td><td>c ** =a -&gt; c=c ** a</td></tr><tr><td>//=</td><td>整除运算符</td><td>c//=a -&gt; c=c//a</td></tr></tbody></table><h4 id="b-kb-mb-gb-的转换">b kb mb gb 的转换</h4><ul class="lvl-0"><li class="lvl-2"><p>b kb mb gb 是计算机的计量单位</p></li><li class="lvl-2"><p>1024相差量</p></li></ul><h4 id="字符串与数字的乘法">字符串与数字的乘法</h4><ul class="lvl-0"><li class="lvl-2"><p>字符串无法与字符串做乘法</p></li><li class="lvl-2"><p>字符串只可以和数字作乘法</p></li></ul><h3 id="比较运算符">比较运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>==</td><td>判断是否等于</td><td>a==b</td></tr><tr><td>!=</td><td>判断是否不等于</td><td>a!=b</td></tr><tr><td>&gt;</td><td>判断是否大于</td><td>a&gt;b</td></tr><tr><td>&lt;</td><td>判断是否小于</td><td>a&lt;b</td></tr><tr><td>&gt;=</td><td>判断是否大于等于</td><td>a&gt;=b</td></tr><tr><td>&lt;=</td><td>判断是否小于等于</td><td>a&lt;=b</td></tr><tr><td><mark>&lt;&gt;</mark></td><td><mark>判断是否不等于</mark></td><td>a&lt;&gt;b</td></tr><tr><td>is</td><td>判断两个对象存储单元是否相同</td><td>a is b</td></tr><tr><td>is not</td><td>判断两个对象存储单元是否不同</td><td>a is not b</td></tr></tbody></table><blockquote><p>注：&lt;&gt;在python3里已经废弃，仅python2里可用</p><p>​       <mark>单元存储</mark> 就是我们提过的<mark>内存块</mark></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
