<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>misc的基本解题思路(二)</title>
      <link href="/posts/e560.html"/>
      <url>/posts/e560.html</url>
      
        <content type="html"><![CDATA[<p><strong>misc的四大部分：</strong></p><ul class="lvl-0"><li class="lvl-2">文件操作与隐写</li><li class="lvl-2">图片隐写术</li><li class="lvl-2">压缩文件处理</li><li class="lvl-2">流量取证技术</li></ul><h2 id="压缩文件处理">压缩文件处理</h2><h3 id="压缩文件分析">压缩文件分析</h3><ol><li class="lvl-3"><p><strong>伪加密</strong></p><p>如果压缩文件是加密的，或文件头正常但解压缩错误，首先尝试文件是否为伪加密。zip文件是否加密是通过识别符来显示的，在每个文件的文件目录字段有一位专门标识了文件是否加密，将其设置为00表示</p><p><mark>使用场景：伪加密文件</mark></p><p><code>操作方法：使用winhex打开压缩文件，找到文件头第九第十个字符，将其修改为0000.</code></p><ol><li class="lvl-6"><p>使用winhex打开文件搜索16进制504B0102，可以看到每个加密文件头字段</p></li><li class="lvl-6"><p>从50开始计算，第九第十个字符为加密字段，将其设置为0000即为可变成无加密状态</p></li><li class="lvl-6"><p>RAR文件由于有头部校验，使用伪加密打开文件会出现报错，使用winhex修改标志位后如报错消失且正常解压缩，说明是伪加密。使用winhex打开RAR文件，找到第24个字节，该字节尾数为4表示加密，0表示无加密，将尾数改为0即可破解伪加密。</p></li></ol></li><li class="lvl-3"><p><strong>暴力破解</strong></p><p>通常可以使用ARCHPR.exe工具来破解zip文件</p><p><mark>使用场景：Windows下加密过的zip文件</mark></p><ol><li class="lvl-6"><p>攻击类型选择暴力破解，在范围位置根据提示选择暴力破解范围选项设置暴力破解包含的类型，开始于和结束于选项具体范围，如果没有定义则全范围暴力破解。</p><p><code>点击打开选择要破解的文件，点击开始进行破解。建议使用1~9位的数字密码，以及系统自带的英文字典作为密码字典</code></p></li><li class="lvl-6"><p>攻击类型选择掩码可以进行复杂的暴力破解，比如知道密码前3位是<mark>abc</mark>，后3位为数字，则在攻击类型选择掩码，在掩码处输入<mark>abc???</mark>，暴力范围选项选择所有数字，打开要破解的点击，点击破解。此时==???==的部分会被我们选择的暴力破解范围中字符代替。</p></li></ol></li><li class="lvl-3"><p><strong>明文攻击</strong></p><p>明文攻击指知道加密的ZIP中部分文件的明文内容，利用这些内容推测出密钥并解密ZIP文件方法，相比于暴力破解，这种方法在破解密码较为复杂的压缩包时效率更高。</p><p><mark>使用场景：已知加密的ZIP部分文件明文内容</mark></p><p>例：假设一个加密的压缩包中有两个文件readme.txt和flag.txt，其中flag.txt的内容是我们希望知道的内容，而我们拥有readme.txt的明文文件，使用上述两个文件即可进行明文攻击。</p><p><code>操作：</code></p><p><code>1、将readme.txt的明文文件进行压缩，变成readme1.zip</code></p><p><code>2、打开archpr，攻击类型选择明文，明文文件路径选择readme1.zip（即将明文文件不加密压缩后的文件），加密的文件</code></p><p><code>选择要破解的文件，点击开始，破解成功后会获得密码。</code></p><blockquote><p>使用该方法需要注意两个关键点：</p><p>1、有一个明文文件，压缩后CRC值与加密压缩包中的文件一致。</p><p>2、明文文件的压缩算法需要与加密压缩文件的压缩算法一致。</p></blockquote><p><strong>RAR文件格式</strong></p><p><mark>有时候给出的RAR文件的头部各个字块会会故意给错误导致无法识别。</mark></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302020003592.png" alt="RAR文件格式"></p></li></ol><h2 id="流量取证技术">流量取证技术</h2><p>CTF比赛中，<mark>流量包的取证分析</mark>是另一项重要的考察方向。</p><p>通常比赛中会提供一个包含流量数据的PCAP文件，有时候也会需要选手们先进行修复或重构传输文件后，再进行分析。</p><ul class="lvl-0"><li class="lvl-2"><p>总体把握</p><ul class="lvl-2"><li class="lvl-4">协议分级</li><li class="lvl-4">端点统计</li></ul></li><li class="lvl-2"><p>过滤筛选</p><ul class="lvl-2"><li class="lvl-4">过滤语法</li><li class="lvl-4">Host，Protocol，contains，特征值</li></ul></li><li class="lvl-2"><p>发现异常</p><ul class="lvl-2"><li class="lvl-4">特殊字符串</li><li class="lvl-4">协议某字符</li><li class="lvl-4">flag位于服务器中</li></ul></li><li class="lvl-2"><p>数据提取</p><ul class="lvl-2"><li class="lvl-4">字符串取</li><li class="lvl-4">文件提取</li></ul></li></ul><p><mark>总的来说比赛中的流量分析可以概括为以下三个方向：</mark></p><ul class="lvl-0"><li class="lvl-2"><p>流量包修复</p></li><li class="lvl-2"><p>协议分析</p></li><li class="lvl-2"><p>数据提取</p></li></ul><h3 id="流量数据包文件分析">流量数据包文件分析</h3><p><strong>WireShark工具的基本使用</strong></p><p>wirkshark的过滤器和过滤规则能够帮助我们迅速定位到要分析的报文。</p><p><mark>常用的过滤命令：</mark></p><ol><li class="lvl-3"><p>过滤IP，如源IP或者目标 x.x.x.x</p><p><code>ip.src eq x.x.x.x or ip.dst eq x.x.x.x 或者 ip.addr eq x.x.x.x</code></p></li><li class="lvl-3"><p>过滤端口</p><p><code>tcp.port eq 80 or udp.port eq 80</code></p><p><code>tcp.dstport == 80</code>    只显示tcp协议的目标端口为80</p><p><code>tcp.srcport == 80</code>    只显示tcp协议的源端口为80</p><p><code>tcp.port &gt;= 1 and tcp.port &lt;= 80</code></p></li></ol><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果自行承担，责任与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的排序算法(一)</title>
      <link href="/posts/6547.html"/>
      <url>/posts/6547.html</url>
      
        <content type="html"><![CDATA[<h2 id="列表排序">列表排序</h2><ul class="lvl-0"><li class="lvl-2"><p>排序：将一组“无序”的记录序列调整为“有序”的记录序列</p></li><li class="lvl-2"><p>列表排序：将无序列表变为有序列表</p><ul class="lvl-2"><li class="lvl-4">输入：列表</li><li class="lvl-4">输出：有序列表</li></ul></li><li class="lvl-2"><p>升序与降序</p></li><li class="lvl-2"><p>内置排序函数：<mark>sort()</mark></p></li></ul><h2 id="冒泡排序-Bubble-Sort">冒泡排序(Bubble Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>列表每两个相邻的数，如果前面比后面大，则交换这两个数</p></li><li class="lvl-2"><p>一趟排序完成后，则无序区减少一个数，有序区增加一个数</p></li><li class="lvl-2"><p>代码关键点：趟、无序区范围</p></li></ul><p><strong>代码示例</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import randomdef bubble_sort(li):    for i in range(len(li)-1):  # 第i趟        for j in range(len(li)-i):            if li[j]&gt;li[j+1]:                li[j],li[j+1]=li[j+1],li[j]#验证li = [random.randint(0,10000) for i in range(1000)]print(li)bubble_sort(li)print(li)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(n<sup>2</sup>)</p></li></ul><p><mark>冒泡排序-优化</mark>：</p><ul class="lvl-0"><li class="lvl-2"><p>如果冒泡排序中的一趟排序没有发生交换，则说明列表已经有序，可以直接结束算法。</p></li></ul><p><strong>代码示例</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def bubble_sort(li):    for i in range(len(li)-1):        exchange = False        for j in range(len(li)-i-1):            if li[j] &gt; li[j+1]:                li[j], li[j+1] = li[j+1], li[j]                 exchange = True            if not exchange:                return<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(n<sup>2</sup>)</p></li></ul><h2 id="选择排序-Select-Sort">选择排序(Select Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>一趟排序记录最小的数，放到第一个位置</p></li><li class="lvl-2"><p>再一趟排序记录列表无序最小的数，放到第二个位置</p></li><li class="lvl-2"><p>…</p></li><li class="lvl-2"><p>算法关键点：有序和无序区、无序区最小数的位置</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def select_sort(li):    for i in range(len(li)-1):        min_loc = i        for j in range(i+1,len(li)):            if li[j] &lt; li[min_loc]:                min_loc = j        if min_loc != i:            li[i], li[min_loc] = li[min_loc], li[i]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入排序-Inset-Sort">插入排序(Inset Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>初始时手里（有序区）只有一张牌</p></li><li class="lvl-2"><p>每次（从无序区）摸一张牌，插入到手里已有牌的正确位置</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def insect_sort(li):    for i in range(1,len(li)):        tmp = li[i]        j = i - 1        while j &gt;= 0 and tmp &lt; li[j]:            li[j+1] = li[j]            j = j - 1         li[j+1] = tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(n<sup>2</sup>)</p></li></ul><h2 id="快速排序-Quick-Sort">快速排序(Quick Sort)</h2><ul class="lvl-0"><li class="lvl-2"><p>快速排序：<mark>快</mark></p></li><li class="lvl-2"><p>快速排序思路：</p><ul class="lvl-2"><li class="lvl-4">取一个元素p（第一个元素），使元素p归位；</li><li class="lvl-4">列表被p分成两部分，左边都比p小，右边都比p大；</li><li class="lvl-4">递归完成排序</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302062134346.png" alt=""></p><p><strong>快速排序-框架：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def quick_sort(data,left,right):    if left &lt; right:        mid = partition(data,left,right)        quick_sort(data,left,mid-1)        quick_sort(data,mid+1,right)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def partition(li,left,right):    tmp = li[left]    while left &lt; right:        while li[right] &gt;= tmp:  # 从右边找比tmp小的数            right -= 1  # 往左走一步        li[left] = li[right]  # 把右边的值写到左边空位上        while left &lt; right and li[left] &lt;= tmp:            left += 1        li[left] = tmp  # 把tmp归位        return leftdef quick_sort(li,left,right)    :    if left &lt; right:  # 至少两个元素        mid = partition(li,left,right)        quick_sort(li,left,mid-1)        quick_sort(li,mid+1,right)#调用测试li = [5,7,6,3,1,2,9,8]quick_sort(li,0,len(li)-1)print(li)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>快速排序的效率：</p><ul class="lvl-2"><li class="lvl-4">快速排序的时间复杂度：<mark>O(nlogn)</mark></li></ul></li><li class="lvl-2"><p>快速排序的问题</p><ul class="lvl-2"><li class="lvl-4"><p>最坏情况：</p><p>正序或逆序排列，二叉树画出来应该是一棵斜树，并且需要经过n-1次递归调用才能完成，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置，所以：</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302091721179.png" alt=""></p><p>最终的时间复杂度应该O(n<sup>2</sup>)</p></li><li class="lvl-4"><p>递归：消耗一部分系统资源</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的排序算法(二)</title>
      <link href="/posts/a5e3.html"/>
      <url>/posts/a5e3.html</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序前传-树与二叉树">堆排序前传 - 树与二叉树</h2><h3 id="树">树</h3><ul class="lvl-0"><li class="lvl-2"><p>树是一种数据结构</p></li><li class="lvl-2"><p>树是一种可以递归定义的数据结构</p></li><li class="lvl-2"><p>树是由几个节点组成的集合</p><ul class="lvl-2"><li class="lvl-4">如果n=0，那这是一棵空树；</li><li class="lvl-4">如果n&gt;0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树。</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092044487.png" alt="树的数据结构"></p><ul class="lvl-0"><li class="lvl-2"><p>一些概念</p><ul class="lvl-2"><li class="lvl-4">根节点、叶子节点</li><li class="lvl-4">树的深度（高度）</li><li class="lvl-4">树的度</li><li class="lvl-4">孩子节点/父节点</li><li class="lvl-4">子树</li></ul></li></ul><h3 id="二叉树">二叉树</h3><ul class="lvl-0"><li class="lvl-2"><p>二叉树：度不超过2的树</p></li><li class="lvl-2"><p>每个节点最多有两个孩子节点</p></li><li class="lvl-2"><p>两个孩子节点被区分为左孩子节点和右孩子节点</p></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092100182.png" alt="二叉树的数据结构"></p><h3 id="完全二叉树">完全二叉树</h3><ul class="lvl-0"><li class="lvl-2"><p>满二叉树：一个二叉树，如果每个层的结点数都达到最大值，则这个二叉树就是满二叉树。</p></li><li class="lvl-2"><p>完全二叉树：叶节点只能出现在最下和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</p></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092105198.png" alt="完全二叉树的图示"></p><h3 id="二叉树的存储方式">二叉树的存储方式</h3><ul class="lvl-0"><li class="lvl-2"><p>二叉树的存储方式（表示方式）</p><ul class="lvl-2"><li class="lvl-4"><mark>链式存储方式</mark></li><li class="lvl-4"><mark>顺序存储方式</mark></li></ul></li></ul><h3 id="二叉树的顺序存储方式">二叉树的顺序存储方式</h3><p><mark>如图所示</mark></p><ul class="lvl-0"><li class="lvl-2"><p>父节点和左孩子节点的编号下标有什么关系？</p><ul class="lvl-2"><li class="lvl-4">0-1 1-3 2-5 3-7 4-9</li><li class="lvl-4">i-&gt;2i+1</li></ul></li><li class="lvl-2"><p>父节点和右孩子节点的编号下标有什么关系？</p><ul class="lvl-2"><li class="lvl-4">0-2 1-4 2-6 3-8 4-10</li><li class="lvl-4">i-&gt;2i+2</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092117768.png" alt="二叉树的顺序存储方式"></p><h2 id="堆排序">堆排序</h2><h3 id="什么是堆">什么是堆</h3><ul class="lvl-0"><li class="lvl-2"><p>堆：一种特殊的完全二叉树结构</p><ul class="lvl-2"><li class="lvl-4">大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li><li class="lvl-4">小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302092129845.png" alt="大根堆和小根堆"></p><h3 id="堆的向下调整性质">堆的向下调整性质</h3><ul class="lvl-0"><li class="lvl-2"><p>假设根节点的左右子树都是堆，但根节点不满足堆的性质</p></li><li class="lvl-2"><p>可以通过一次向下的调整来将其变成一个堆</p></li></ul><h3 id="堆排序过程">堆排序过程</h3><ul class="lvl-0"><li class="lvl-2"><p>1.建立堆</p></li><li class="lvl-2"><p>2.得到堆顶元素，为最大元素</p></li><li class="lvl-2"><p>3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序</p></li><li class="lvl-2"><p>4.堆顶元素为第二大元素</p></li><li class="lvl-2"><p>5.重复步骤3，直到堆变空</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def sift(li,low,high):    # li：列表    # low：堆的根节点位置    # high：堆的最后一个元素的位置    i = low  # i最开始指向根节点    j = 2 * i + 1  # j开始是左孩子    tmp = li[low]  # 把堆顶存起来    while j &lt;= high:  # 只要j位置有数        if j + 1 &lt;= high and li[j+1] &gt; li[j]:  # 如果右孩子有并且比较大            j = j + 1  # j指向右孩子        if li[j] &gt; tmp:            li[i] = li[j]            i = j  # 往下看一层            j = 2 * i + 1        else:  # tmp更大，把tmp放到i的位置上            li[i] = tmp  # 把tmp放到某一级领导位置上            break    else:        li[i] = tmp  # 把tmp放到叶子节点上        def heap_sort(li):    n = len(li)    for i in range((n-2)//2,-1,-1):        # i表示建堆的时候调整的部分的根下标        sift(li,i,n-1)    # 建堆完成了    for i in range(n-1,-1,-1):        # i指向当前堆的最后一个元素        li[0], li[i] = li[i], li[0]        sift(li,0,i-1)  # i-1是新的high<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(nlogn)</p></li></ul><h3 id="内置模块">内置模块</h3><ul class="lvl-0"><li class="lvl-2"><p>python内置模块–heapq</p></li><li class="lvl-2"><p>常用函数</p><ul class="lvl-2"><li class="lvl-4">heapify(x)</li><li class="lvl-4">heappush(heap,item)</li><li class="lvl-4">heappop(heap)</li></ul></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import heapqimport randomli = list(range(100))random.shuffle(li)print(li)heapq.heapify(li)  # 建堆n = len(li)for i in range(n):    print(heapq.heappop(li),end=',')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="topk问题">topk问题</h3><ul class="lvl-0"><li class="lvl-2"><p>现在有n个数，设计算法得到前k大的数。（k&lt;n）</p></li><li class="lvl-2"><p>解决思路：</p><ul class="lvl-2"><li class="lvl-4">排序后切片      <mark>O(nlogn)</mark></li><li class="lvl-4">冒泡排序 选择排序 插入排序    <mark>O(mn)</mark></li><li class="lvl-4">堆排序思路   <mark>O(mlogn)</mark></li></ul></li></ul><blockquote><p>堆排序解决思路：</p><ul class="lvl-1"><li class="lvl-2">取列表前k个元素建立一个小根堆。堆顶就是目前第k大的数</li><li class="lvl-2">依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整</li><li class="lvl-2">遍历列表所有元素后，倒序弹出堆顶</li></ul></blockquote><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def sift(li,low,high):    # li：列表    # low：堆的根节点位置    # high：堆的最后一个元素的位置    i = low  # i最开始指向根节点    j = 2 * i + 1  # j开始是左孩子    tmp = li[low]  # 把堆顶存起来    while j &lt;= high:  # 只要j位置有数        if j + 1 &lt;= high and li[j+1] &lt; li[j]:              j = j + 1  # j指向右孩子        if li[j] &lt; tmp:            li[i] = li[j]            i = j  # 往下看一层            j = 2 * i + 1        else:  # tmp更大，把tmp放到i的位置上            li[i] = tmp  # 把tmp放到某一级领导位置上            break    else:        li[i] = tmp  # 把tmp放到叶子节点上        def topk(li,k):    heap = li[0:k]    for i in range((k-2)//2, -1, -1):        sift(heap,i,k-1)    # 1.建堆    for i in range(k,len(li)-1):        if li[i] &gt; heap[0]:            heap[0] = li[i]            sift(heap,0,k-1)    # 2.遍历    for i in range(k-1, -1, -1):        li[0], li[i] = li[i], li[0]        sift(li,0,i-1)    # 3.出数    return heap# 测试                   import randomli = list(range(1000))random.shuffle(li)print(topk(li,10))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的排序算法(三)</title>
      <link href="/posts/3541.html"/>
      <url>/posts/3541.html</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序">归并排序</h2><h3 id="归并">归并</h3><ul class="lvl-0"><li class="lvl-2"><p>假设现在的列表分两段，如何将其合成一个有序列表</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302191523668.png" alt="归并排序"></p></li><li class="lvl-2"><p>这种操作称为一次归并</p></li></ul><h3 id="使用归并">使用归并</h3><ul class="lvl-0"><li class="lvl-2"><p>分解：将列表越分越小，直至分成一个元素</p></li><li class="lvl-2"><p>终止条件：一个元素是有序的</p></li><li class="lvl-2"><p>合并：将两个有序列表归并，列表越来越大</p></li></ul><p><strong>代码示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def merge(li,low,high):    i = low    j = mid + 1    ltmp = []    while i&lt;mid and j&lt;=high:  # 只要左右两边都有数        if li[i] &lt; li[j]:            ltmp.append(li[i])            i += 1        else:            ltmp.append(li[j])            j += 1    # while执行完，肯定有一部分没数了    while i &lt;= mid:        ltmp.append(li[i])        i += 1    while j &lt;= high:        ltmp.append(li[i])        j += 1    li[low:high+1] = ltmp            def merge_sort(li,low,hight):    if low &lt; high:  # 至少有两个元素，递归        mid = (low + high) // 2        merge_sort(li,low,mid)        merge_sort(li,mid+1,high)        merge(li,low,mid,high)        #测试li = list(range(1000))import randomrandom.shuffle(li)print(li)merge_sort(li,0,len(li)-1)print(li)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p><mark>时间复杂度：O(nlogn)</mark></p></li><li class="lvl-2"><p>空间复杂度：O(n)</p></li></ul><h2 id="小结">小结</h2><ul class="lvl-0"><li class="lvl-2"><p>三种排序算法的时间复杂度都是O(nlogn)</p></li><li class="lvl-2"><p>一般情况下，就运行时间而言：</p><ul class="lvl-2"><li class="lvl-4">快速排序 &lt; 归并排序 &lt; 堆排序</li></ul></li><li class="lvl-2"><p>三种排序算法的缺点：</p><ul class="lvl-2"><li class="lvl-4">快速排序：极端情况下排序效率低</li><li class="lvl-4">归并排序：需要额外的内存开销</li><li class="lvl-4">堆排序：在快的排序算法中相对较慢</li></ul></li></ul><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302191554786.png" alt="小结"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法中的列表查找</title>
      <link href="/posts/4c50.html"/>
      <url>/posts/4c50.html</url>
      
        <content type="html"><![CDATA[<h2 id="查找">查找</h2><ul class="lvl-0"><li class="lvl-2"><p>查找：在一些数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程</p></li><li class="lvl-2"><p>列表查找（线性表查找）：从列表中查找指定元素</p><ul class="lvl-2"><li class="lvl-4">输入：列表、待查找元素</li><li class="lvl-4">输出：元素下标（未找到元素时一般返回None或-1）</li></ul></li><li class="lvl-2"><p>内置列表查找函数：index()</p></li></ul><h2 id="顺序查找-Linear-Search">顺序查找(Linear Search)</h2><ul class="lvl-0"><li class="lvl-2"><p>顺序查找：也叫线性查找，从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止</p></li><li class="lvl-2"><p>时间复杂度：O(n)</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def linear_search(li,val):    for ind ,v in emumerate(li):        if v == val:            return ind        else:            return None#或者def linear_search(data_set,value):    for i in range(range(data_set)):        if data_set[i] == value:            return i     return <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二分查找-Binar-Search">二分查找(Binar Search)</h2><ul class="lvl-0"><li class="lvl-2"><p>二分查找：又叫折半查找，从有序列表的初始候选区 li[0:n] 开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def binary_search(li,val):   # val：元素    left = 0    right = len(li) - 1    while left &lt;= right:# 候选区有值        mid = (left + right)// 2        if li[mid] == val:            return mid        elif li[mid] &gt; val: # 带查找的值在mid左侧            right = mid -1        else:   # li[mid] &lt; val 带查找的值在mid右侧            left = mid + 1      else:             return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul class="lvl-0"><li class="lvl-2"><p>时间复杂度：O(logn)</p></li></ul><p><mark>测试运行时间代码</mark>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timedef cal_time(func):    def wrapper(*args,**kwargs):        t1 = time.time()        result = func(*args,**kwargs)        t2 = time.time()        print("%s running time: %s secs." % (func.__name__,t2-t1))        return result    return wrapper# 运用时，先导入这个模块，再用@cal_time语句放在函数代码，如：@cal_timedef binary_search(li,val):   # val：元素    left = 0    right = len(li) - 1    while left &lt;= right:# 候选区有值        mid = (left + right)// 2        if li[mid] == val:            return midcal_time        elif li[mid] &gt; val: # 带查找的值在mid左侧            right = mid -1        else:   # li[mid] &lt; val 带查找的值在mid右侧            left = mid + 1      else:             return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：内置函数 index() 用的是线性查找。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>misc的基本解题思路(一)</title>
      <link href="/posts/b478.html"/>
      <url>/posts/b478.html</url>
      
        <content type="html"><![CDATA[<p><strong>misc的四大部分：</strong></p><ul class="lvl-0"><li class="lvl-2">文件操作与隐写</li><li class="lvl-2">图片隐写术</li><li class="lvl-2">压缩文件处理</li><li class="lvl-2">流量取证技术</li></ul><h2 id="文件操作与隐写">文件操作与隐写</h2><h3 id="文件类型识别">文件类型识别</h3><ol><li class="lvl-3"><p>File命令</p><p>当文件没有后缀名或者有后缀名而无法打开时，根据识别出的文件类型来修改后缀名即可正常打开文件。</p><p><mark>使用场景：不知道后缀名，无法打开文件</mark></p><p><code>Linux环境下命令格式：file+文件名</code></p></li><li class="lvl-3"><p>winhex</p><p>通过<mark>winhex</mark>程序中可以查看文件头类型，根据头类型判断文件类型</p><p><mark>使用场景：windows下通过文件头信息判断文件类型</mark></p></li></ol><p><strong>常见的文件头类型如下：</strong></p><table><thead><tr><th>文件类型</th><th>文件头</th></tr></thead><tbody><tr><td>JPEG(jpg)</td><td>FFD8FFE1</td></tr><tr><td>PNG(png)</td><td>89504E47</td></tr><tr><td>GIF(gif)</td><td>47494638</td></tr><tr><td>TIFF(tiff)</td><td>49492A00</td></tr><tr><td>Windows Bitmap(bmp)</td><td>424DC001</td></tr><tr><td>ZIP Archive(ZIP)</td><td>504B0304</td></tr><tr><td>RAR Archive(rar)</td><td>52617221</td></tr><tr><td>Adobe Photshop(psd)</td><td>38425053</td></tr><tr><td>Rich Text Format(rtf)</td><td>7B5C727466</td></tr><tr><td>XML(xml)</td><td>3C3F786D6C</td></tr><tr><td>HTML(html)</td><td>68746D6C3E</td></tr><tr><td>Adobe Acrobat(pdf)</td><td>255044462D312E</td></tr><tr><td>Wave(wav)</td><td>57415645</td></tr><tr><td>pacp</td><td>4D3C2B1A</td></tr></tbody></table><ol start="3"><li class="lvl-3"><p>文件头残缺/错误</p><p>通常文件无法正常打开有两种情况，一种文件头部残缺，另一种头部字段错误。针对文件头部残缺的情况，使用winhex程序添加相应的文件头，针对头部字段错误，可以找一个相同类型的文件进行替换。</p><p><mark>使用场景：文件头部残缺或文件头部字段错误无法打开正常文件</mark></p><p><code>格式：file 文件名</code></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011320661.png" alt=""></p></li></ol><h3 id="文件分离操作">文件分离操作</h3><ol><li class="lvl-3"><p><strong>Binwalk工具</strong></p><p><strong>Binwalk</strong>工具是Linux下用来分析和分离文件的工具，可以快速分辨文件是否由多个文件合并而成，并将文件进行分离。如果分离成功会在目标文件的目录。</p><p>同目录下生成一个形如_文件名_extracted的文件目录，目录中有分离后的文件。</p><p><mark>用法</mark>：</p><p><code>分析文件：binwalk filename</code></p><p><code>分离文件：binwalk -e filename</code></p><blockquote><p>注：binwalk遇到压缩包会自动解压。</p></blockquote></li><li class="lvl-3"><p><strong>formost</strong></p><p>如果<strong>binwalk</strong>无法正确分离文件，可以使用<strong>foremost</strong>，将目标文件复制到kali中，成功执行后，会在目标文件的文件目录下生成我们设置的目录，目录中会按文件类型分离出文件。</p><p><mark>用法</mark>：</p><p><code>foremost 文件名 -o 输出目录名</code></p></li><li class="lvl-3"><p><strong>dd</strong></p><p>当文件自动分离出错或者因为其他原因无法自动分离时，可以使用<strong>dd</strong>实现文件手动分离。</p><p><code>格式：dd if=源文件 of=目标文件名 bs=1 skip=开始分离的字节数</code></p><p><mark>参数说明</mark>：</p><p><code>if=file  #输入文件名，缺省为标准输入</code></p><p><code>of=file  #输出文件名，缺省为标准输出</code></p><p><code>bs=bytes  #同时设置读写块的大小为bytes，可代替ibs和obs</code></p><p><code>skip=blocks  #从输入文件开头跳过blocks个块后再开始复制</code></p></li><li class="lvl-3"><p><strong>Winhex</strong></p><p>除了使用dd外，还可以使用winhex实现文件手动分离，将目标文件拖入问winhex中，找到要分离的部分，点击复制即可。</p><p><mark>使用场景：Windows下利用winhex程序对文件进行手动分离</mark></p></li><li class="lvl-3"><p><strong>010Editor</strong></p><p><mark>将某块区域文件保存的方式如下：</mark></p><ol><li class="lvl-6"><p>010Editor打开文件 -&gt; 选中右键 -&gt; Selection -&gt; Save Selection</p></li></ol><p><mark>将16进制字符文件导入保存操作方法如下：</mark></p><ol><li class="lvl-6"><p>将16进制字符文件保存在一个文件</p></li><li class="lvl-6"><p>打开010Editor import Hex</p></li><li class="lvl-6"><p>另存为一个文件，后缀名以010Editor获取到它本身文件信息而定</p></li></ol></li></ol><h3 id="文件合并操作">文件合并操作</h3><ol><li class="lvl-3"><p><strong>Linux下的文件合并</strong></p><p><mark>使用场景：Linux下，通常对文件名相似的文件要进行批量合并</mark></p><p><code>格式：cat 合并的文件 &gt; 输出的文件</code></p><p><mark>完整性检测：Linux下计算文件md5：</mark></p><p><code>md5sum 文件名</code></p></li><li class="lvl-3"><p><strong>Windows下的文件合并</strong></p><p><mark>使用场景：Windows下，通常要对文件 名相似的文件进行批量合并</mark></p><p><code>格式：copy /B 合并的文件 输出的文件命令</code></p><p><mark>完整性检测：Windows下计算文件md5：</mark></p><p><code>certutil -hashfiel 文件名 md5</code></p></li></ol><h3 id="文件内容隐写">文件内容隐写</h3><p>文件内容隐写，就是直接将KEY以十六进制的形式写在文件中，通常在文件的开头或结尾部分，<mark>分析时通常重点观察文件开头和结尾部分</mark>。如果在文件中间部分，通常搜索关键字<strong>KEY</strong>或者<strong>flag</strong>来查找隐藏内容。</p><p><mark>使用场景：Windows下，搜索隐写的文件内容</mark></p><ol><li class="lvl-3"><p>winhex/010Editor</p><p>通常将识别的文件拖入<strong>winhex</strong>中，查找具有关键字或明显与文件不和谐的部分，通常优先观察文件首部和尾部，搜索flag或key等关键字，最后拖动滚轮寻找。</p></li><li class="lvl-3"><p>Notepad++</p><p>使用<strong>Notepad++<strong>打开文件，查看文件头尾是否有含有关键字的字符串，搜索</strong>flag</strong>或<strong>key</strong>等关键字，最后拖动滚轮寻找。</p><p>另外通过安装插件HEX-Editor可以实现winhex的功能</p></li></ol><h2 id="图片隐写术">图片隐写术</h2><h3 id="图片隐写的常见隐写方法">图片隐写的常见隐写方法</h3><ol><li class="lvl-3"><p><strong>细微的颜色差别</strong></p></li><li class="lvl-3"><p><strong>GIF图多帧隐藏</strong></p><ol><li class="lvl-6">颜色通道隐藏</li><li class="lvl-6">不同帧图信息隐藏</li><li class="lvl-6">不同帧对比隐写</li></ol></li><li class="lvl-3"><p><strong>Exif信息隐藏</strong></p></li><li class="lvl-3"><p><strong>图片修复</strong></p><ol><li class="lvl-6">图片头修复</li><li class="lvl-6">图片尾修复</li><li class="lvl-6">CRC校验修复</li><li class="lvl-6">长、宽、高度修复</li></ol></li><li class="lvl-3"><p><strong>最低有效位LSB隐写</strong></p></li><li class="lvl-3"><p><strong>图片加密</strong></p><ol><li class="lvl-6">Stedetect</li><li class="lvl-6">outguess</li><li class="lvl-6">F5</li></ol></li></ol><h3 id="图片文件隐写">图片文件隐写</h3><ol><li class="lvl-3"><p><strong>Firework</strong></p><p>使用<strong>winhex</strong>打开文件时会看到文件头部中包含f<strong>irework</strong>的标识，通过<strong>firework</strong>可以找到隐藏图片。</p><p><mark>使用场景：查看隐写的图片文件</mark></p></li><li class="lvl-3"><p><strong>Exif</strong></p><p><strong>Exif</strong>按照JPEG的规格在JPEG中插入一些图像/数字相机的信息数据以及缩略图像，可以通过与JPEG兼容的互联浏览器/图片浏览器/图片处理等一些软件来查看<strong>Exif</strong>格式的图片文件，就跟浏览器通常JPEG图像文件一样。</p><p>图片右键属性，查看Exif或查看详细信息，在相关选项卡中看找flag信息。</p><p>如果是Linux环境下，可以用<strong>exiftool</strong>工具，<code>命令：exiftool 文件名（带后缀名）</code></p></li><li class="lvl-3"><p><strong>Stegsolve</strong></p><p>当两张图片外观、大小、像素都基本相同时，可以考虑进行结合分析，即将两个文件的像素RGB值进行XOR、ADD、SUB等操作，看能否得到有用的信息，Stegsolve可以方便地进行这些操作。</p><p><mark>使用场景：两张图片信息基本相同</mark></p><ol><li class="lvl-6"><p>打开第一张图片，点击analyse -&gt; Image combiner</p></li><li class="lvl-6"><p>在弹出的窗口中点击左右按钮选择处理方式，点击save保存有价值的结果</p></li></ol></li><li class="lvl-3"><p><strong>LSB（最低有效位Least Significant Bit)</strong></p><p><strong>LSB</strong>替换隐写基本思想是用嵌入的秘密信息取代载体图像的最低特位，原来的7个高位平面与替代秘密信息的最低位平面组合成含有隐藏信息的新图形。</p><ol><li class="lvl-6"><p>像素三原色（RGB）</p></li><li class="lvl-6"><p>通过修改像素中最低位的1bit来达到隐藏的效果</p></li><li class="lvl-6"><p>工具：stegsolve、zsteg、wbstego4、python脚本</p></li><li class="lvl-6"><p><strong>Stegsolve.jar工具</strong></p><ol><li class="lvl-9">打开文件 -&gt; Analyse -&gt; Data Extract</li><li class="lvl-9">调整Bit Plans，Bits Order，Bit Plane Order</li></ol></li><li class="lvl-6"><p><strong>zsteg工具</strong></p><p><mark>检测LSB隐写：</mark></p><p><code>命令：zsteg xxx.png</code></p></li><li class="lvl-6"><p><strong>wbstego4工具</strong></p><p>解密通过1sb加密的图片</p></li><li class="lvl-6"><p><strong>python脚本来处理</strong></p><p>将目标文件放在以下脚本目录下，将脚本中的文件名修改为你的目标文件名，运行python脚本即可</p><blockquote><p>注：要在python2的环境运行。</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">#coding:utf-8import PIL.Imagedef foo():    im = PIL.Image.open('01.bmp')  #将'01.bmp'修改为你的目标文件名     im2 = im.copy()    pix = im2.load()    width,height = im2.size        for x in xrange(0,width):        for y in xrange(0,height):            if pix[x.y]&amp;0x1 == 0:                pix[x,y] = 0            else:                pix[x,y] = 255    im2.show()    passif __name__=='__main__':    foo()    print 'ok.'    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li class="lvl-3"><p>TTweakPNG</p><p><strong>TweakPNG</strong>是一款简单易用的PNG图像浏览工具，它允许查看和修改一些PNG图像文件的元信息存储。</p><p><mark>使用场景：文件头正常却无法打开文件，利用TweakPNG修CRC</mark></p><p>例：</p><ol><li class="lvl-6"><p>当PNG文件头正常但无法打开文件，可能是CRC校验出错，可以尝试通过TweakPNG打开PNG，会弹出校验错误的提示，这里显示CRC是fe1a5ab6，正确的是b0a7a9f1。打开winhex搜索fe1a5ab6将其改为b0a7a9f1</p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011629751.png" alt=""></p></li></ol><p><mark>有时CRC没有错误，但是图片的高度或者宽度发生了错误，需要通过CRC计算出正确的高度或者宽度。</mark></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011652177.png" alt=""></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#cooding:utf-8import binasciiimport structcrcbp = open("xxx.png","rb").read()  # 此处将'xxx.png'改成你的目标文件名for i in range(1024):    for j in range(1024):        data = crcbp[12:16]+struct.pack('&gt;i',i)+struct.pack('&gt;i',j)+crcbp[24:29]        crc32 = binascii.crc32(data)&amp;0xffffffff        if crc32 == 0x08ec7edb:  # 此处填上CRC值            print i,j            print "hex".hex(i),hex(j)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li class="lvl-3"><p><strong>Bftools</strong></p><p><strong>bftools</strong>用于解密图片信息</p><p><mark>使用场景：在Windows的cmd下，对加密过的图片文件进行解密</mark></p><p><code>格式：Bftools.exe decode braincopter 要解密的图片名称 -output 输出文件名</code></p><p><code>Bftools.exe run 上一步输出的文件</code></p><p><img src="https://ahao8.oss-cn-guangzhou.aliyuncs.com/img/202302011703200.png" alt=""></p></li><li class="lvl-3"><p><strong>SilentEye</strong></p><p><strong>silenteye</strong>是一款可以将文字或者文件隐藏到图片的解密工具。</p><p><mark>使用场景：Windows下打开silentEye工具，对加密的图片进行解密</mark></p><p>例：</p><ol><li class="lvl-6"><p>使用silentEye程序打开目标图片，点击image -&gt; decode，点击decode，可以查看隐藏文件，点击保存即可</p></li></ol></li><li class="lvl-3"><p>JPG图像加密</p><ol><li class="lvl-6"><p><strong>Stegdetect</strong>工具探测加密方式</p><blockquote><p>Stegdetect程序主要用于分析JPEG文件。因此用Stegdetect可以检测到通过JSteg、JPHide、OutGuess、Invisble Secrets、F5、appendx和Camoutflage等这些隐写工具隐藏的信息。</p></blockquote><p><code>Linux环境下命令：</code></p><p><code>stegdetect xxx,jpg</code></p><p><code>stegdetect -s 敏感度 xxx.jpgexi</code></p></li><li class="lvl-6"><p><strong>Jphide</strong></p><p><strong>Jphide</strong>是基于最低有效位LSB的JPEG格式图像隐写算法。</p><p>例：</p><p>Stegdetect提示jphide加密时，可以用Jphs工具进行解密，打开jphswin.exe，使用open jpeg打开图片，点击seek，输入密码和确认密码，在弹出文件框中选择要保存的解密文件位置即可，结果保存成txt文件。</p></li><li class="lvl-6"><p><strong>Outguess</strong></p><p><strong>Outguess</strong>一般用于解密文件信息</p><p><mark>使用场景：Stegdetect识别出来或者题目提示时outguess加密的图片</mark></p><p><code>格式：outguess -r 要解密的文件名输出结果文件名</code></p></li><li class="lvl-6"><p><strong>F5</strong></p><p><strong>F5</strong>一般用于解密文件信息</p><p><mark>使用场景：Stegdetect识别出来是F5加密的图片或题目提示是F5加密的图片</mark></p><p>进入F5-steganography_F5目录，将图片文件拷贝至该目录下，从CMD进入该目录</p><p><code>格式：Java Exrtact 要解密的文件名 -p 密码</code></p></li></ol></li><li class="lvl-3"><p><strong>二维码处理</strong></p><ol><li class="lvl-6">使用二维码扫描工具CQR.exe打开图片，找到内容字段</li><li class="lvl-6">如果二维码某个定位角被覆盖了，该工具有时候也可以自动识别，如果识别失败，需要使用PS或画图工具将另外几个角的定位符移动到相应的位置，补全二维码。</li><li class="lvl-6">如果某个二维码的定位点中间是白色，可能被反色了，使用画图工具把颜色反色回来再扫描即可。</li></ol></li></ol><blockquote><p>免责声明：本文章涉及的知识和技能仅用于学习研究，如有用于非法途径或未被授权的真实网络环境，所造成的后果自行承担，责任与本文作者无关，倡导把安全知识和技能用于正当、正规、正义的途径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<h2 id="谈谈博客对我的影响">谈谈博客对我的影响</h2><p>本人是一名在读大三的学生，这是我写的第一篇博客文章，经过一番折腾后，虽然中间有点小插曲，但是我还是顺利地完成好搭建这个属于我个人的博客，作为一名长期以自学为主的人来说，我的知识的积累和技术的成长很大程度都离不开博客，先是因为学校无法提供偏技术这方面的培养，我便开始了一段独立且漫长的自学历程，由于我是web安全为主要方向学习，在我个人自学和结合靶场训练的过程，遇到问题也常有的事情，很多时候就去网上查资料学习，这时候我一般去阅读别人的博客文章，看别人是怎么解决问题，思路是怎么样的，涉及那些具体的知识点，我都比较地阅读。慢慢地，就会有一定的知识的积累和对问题解决的方法，当然，像技能的提升种肯定是离不开稳扎稳打的训练。我非常感谢别人的对自己个人知识和技术的分享，以及一些问题的解决，写成博客文章，供大家学习，这种分享的精神，我觉得是非常宝贵和伟大的，想必大多数计算机相关的学习者和我都一样，博客对我们的知识的积累和技术的成长有一定的影响的。</p><h2 id="希望自己也能成为影响他人的人">希望自己也能成为影响他人的人</h2><p>由于自己在学习的过程中有经常记笔记的习惯，并且积累了一定个人自学笔记，我也希望自己写出一些博客文章，供大家作学习参考，这是我个人搭建博客的想法和初衷，如果你觉得我的博客文章写得不错，或者某部分细节能解决你手上棘手的问题的话，你也可以关注一下我的博客，我会尽个人所能写好每一篇博客文章，原创不易，也非常期待你的小赏喔。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据类型</title>
      <link href="/posts/bb2d.html"/>
      <url>/posts/bb2d.html</url>
      
        <content type="html"><![CDATA[<h2 id="python数据类型概况">python数据类型概况</h2><p><strong>数字类型</strong></p><p><strong>字符类型</strong></p><p><strong>布尔类型</strong></p><p><strong>空类型</strong></p><p><strong>列表类型</strong></p><p><strong>元组类型</strong></p><p><strong>字典类型</strong></p><h3 id="整型int">整型int</h3><ul class="lvl-0"><li class="lvl-2"><p>整型就是所说的整数，0也是整数，但是特殊的整数</p></li><li class="lvl-2"><p><mark>int</mark>即是整型的代表，又是定义整型的<mark>内置函数</mark></p></li></ul><h3 id="浮点型">浮点型</h3><ul class="lvl-0"><li class="lvl-2"><p>浮点型就是我们生活中的小数，凡是带有小数点的类型，都可以认为是浮点型</p></li><li class="lvl-2"><p>在python中，<mark>float</mark>既是浮点型的代表，又是浮点型类型定义的内置函数</p></li><li class="lvl-2"><p>定义<mark>float</mark>类型的时候，并不需要一定使用<mark>float</mark>声明</p></li></ul><h3 id="内置函数–type">内置函数–type</h3><ul class="lvl-0"><li class="lvl-2"><p>返回变量的类型</p></li><li class="lvl-2"><p><mark>type</mark>（已经被赋值的变量名或变量）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">count = 1050print(type(count))print(type(3.1415926))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="字符串">字符串</h3><ul class="lvl-0"><li class="lvl-2"><p>用 " 或者 “” 包裹的信息，就是字符串</p></li><li class="lvl-2"><p>字符串中可以包含任意字符：如字母，数字，符号，且没有先后顺序</p></li></ul><h4 id="字符串的定义方法">字符串的定义方法</h4><p>在python中，使用<mark>str</mark>来代表字符串类型，并且通过该函数可以定义字符串</p><h4 id="字符串的重要思想">字符串的重要思想</h4><ul class="lvl-0"><li class="lvl-2"><p>字符串是不可改变的！</p></li></ul><h4 id="内置函数id">内置函数id</h4><ul class="lvl-0"><li class="lvl-2"><p>返回变量的内存地址</p></li><li class="lvl-2"><p>数字地址 = <mark>id</mark>(变量)</p></li></ul><h4 id="内置函数">内置函数</h4><ul class="lvl-0"><li class="lvl-2"><p>返回字符串的长度</p></li><li class="lvl-2"><p>无法返回数字类型的长度，因为数字类型没有长度</p></li><li class="lvl-2"><p>返回 = len(字符串)</p></li></ul><h4 id="内置成员运算符in的使用">内置成员运算符<mark>in</mark>的使用</h4><ul class="lvl-0"><li class="lvl-2"><p>成员运算符是用来判断你的数据中是否存在你想要的成员</p></li></ul><h4 id="内置函数max">内置函数<mark>max</mark></h4><ul class="lvl-0"><li class="lvl-2"><p><mark>max</mark>(数据) -&gt; 成员值     <code>print(max(''今天是1月3日!'))</code>    -&gt; <mark>月</mark></p></li><li class="lvl-2"><p><strong>规则</strong>：中文符号 &gt; 字母 &gt; 数字 &gt; 英文符号</p></li><li class="lvl-2"><p>中文按照拼音的首字母来计算</p></li></ul><h4 id="内置函数min">内置函数<mark>min</mark></h4><ul class="lvl-0"><li class="lvl-2"><p><mark>min</mark>函数返回数据中最小的成员  <code>pinrt(min('今天是1月3日!'))</code>  -&gt; !</p></li><li class="lvl-2"><p>min(数据) &gt; 字母 &gt; 数字 &gt; 英文符号</p></li><li class="lvl-2"><p><strong>规则</strong>：中文符号 &gt; 字母 &gt; 数字 &gt; 英文符号</p></li><li class="lvl-2"><p>中文按照拼音的首字母来计算</p></li></ul><h4 id="字符串的累加">字符串的累加</h4><ul class="lvl-0"><li class="lvl-2"><p>字符串不是数字不能做减法，乘除法</p></li><li class="lvl-2"><p>字符串的拼接，用 “+” 这个符号</p></li></ul><h3 id="布尔类型">布尔类型</h3><ul class="lvl-0"><li class="lvl-2"><p>定义：真假的判断 即 布尔类型</p></li><li class="lvl-2"><p>固定值：True -&gt; 真；False -&gt; 假；</p></li><li class="lvl-2"><p>布尔值</p></li></ul><h4 id="布尔类型的使用">布尔类型的使用</h4><ul class="lvl-0"><li class="lvl-2"><p><mark>bool</mark>代表布尔类型，也可以对于结果进行真假的判读</p></li></ul><h4 id="使用场景">使用场景</h4><ul class="lvl-0"><li class="lvl-2"><p>常被用来判断一件事儿的真假</p></li></ul><h4 id="数字与字符串的布尔应用">数字与字符串的布尔应用</h4><ul class="lvl-0"><li class="lvl-2"><p>int 0 -&gt; False，非0 -&gt; True</p></li><li class="lvl-2"><p>float 0.0 -&gt; False，非0.0 -&gt; True</p></li><li class="lvl-2"><p>str " -&gt; False(即 空字符串)，非空字符串 -&gt; True</p></li><li class="lvl-2"><p>在计算机中0 1是计算机的最原始形态，单个占空间也最小，故而经常会将0 1用来替代True与False</p></li></ul><h3 id="pyhton中的空类型">pyhton中的空类型</h3><ul class="lvl-0"><li class="lvl-2"><p>不属于任何数据类型就是<mark>空类型</mark></p></li><li class="lvl-2"><p>固定值：<mark>None</mark></p></li><li class="lvl-2"><p>空类型 属于 <mark>False</mark>的范畴</p></li><li class="lvl-2"><p>如果不确定类型的时候可以使用<mark>空类型</mark></p></li></ul><h3 id="列表类型">列表类型</h3><ul class="lvl-0"><li class="lvl-2"><p>列表就是队列</p></li><li class="lvl-3"><p>他是各种数据类型的集合，也是一种数据结构</p></li><li class="lvl-2"><p>列表是一种有序，且内容可重复的集合类型</p></li></ul><h4 id="列表的定义">列表的定义</h4><ul class="lvl-0"><li class="lvl-2"><p>在python中，<mark>list</mark>代表这种类型，也可以用它定义一个列表  <code>name_01=list(['',''])</code></p></li><li class="lvl-2"><p>在python中，列表中的元素存在于一个[]中  <code>name_02=['','']</code></p></li><li class="lvl-2"><p>在python中，列表是一个无限制长度的数据结构</p></li></ul><h4 id="列表中的类型">列表中的类型</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>str_array</strong></p></li><li class="lvl-2"><p><strong>int_array</strong></p></li><li class="lvl-2"><p><strong>float_array</strong></p></li><li class="lvl-2"><p><strong>bool_array</strong></p></li><li class="lvl-2"><p><strong>list_array</strong>  列表中嵌套列表</p></li><li class="lvl-2"><p><strong>min_array</strong>  列表中可以放混合类型</p></li></ul><h4 id="in，max，min在列表中的使用">in，max，min在列表中的使用</h4><ul class="lvl-0"><li class="lvl-2"><p>1 in [1,2,3,4] -&gt; True; 10 in  [1,2,3,4] -&gt; False</p></li><li class="lvl-2"><p>max([1,2,3,4]) -&gt; 4</p></li><li class="lvl-2"><p>min([1,2,3,4]) -&gt; 1</p></li><li class="lvl-2"><p>max和min在列表中使用的时候，列表中的元素不能是多种类型，如果类型不统一，则会报错</p></li></ul><h3 id="元组">元组</h3><ul class="lvl-0"><li class="lvl-2"><p>元组和列表一样，都是一种可以存储多种数据结构的队列</p></li><li class="lvl-2"><p>元组也是一个有序的，且元素可以重复的集合</p></li></ul><h4 id="元组的定义">元组的定义</h4><ul class="lvl-0"><li class="lvl-2"><p>在python中，tuple代表着元组这种类型，也可以用它定义一个元组   <code>name_01=tuple('','')</code></p></li><li class="lvl-2"><p>在python中，元组中的元素存在于一个（）小括号中  <code>name_02=('','')</code></p></li><li class="lvl-2"><p>在python中，元组是一个无限制长度的数据结构</p></li></ul><blockquote><p>注：如果元组中只有一个元素，那一定要在这个元素后面加上一个逗号</p></blockquote><h4 id="列表与元组的区别">列表与元组的区别</h4><ul class="lvl-0"><li class="lvl-2"><p>元组比列表占用资源更小</p></li><li class="lvl-2"><p>列表是可变的，元组是不可变的</p></li></ul><h4 id="元组中的类型">元组中的类型</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>str_tuple</strong></p></li><li class="lvl-2"><p><strong>int_tuple</strong></p></li><li class="lvl-2"><p><strong>float_tuple</strong></p></li><li class="lvl-2"><p><strong>bool_tuple</strong></p></li><li class="lvl-2"><p><strong>none_tuple</strong>=(None,None,None)</p></li><li class="lvl-2"><p><strong>tuple_tuple</strong>=((1,2,3),(1.2,3.1))</p></li><li class="lvl-2"><p><strong>list_type</strong>=([123,456],[6789,1234])</p></li><li class="lvl-2"><p><strong>mix_tuple</strong>=(‘’,1,3.14,None,True)</p></li><li class="lvl-2"><p><strong>tuple_array</strong>=[(‘a’,‘b’),(‘c’,‘d’),(‘e’,)]</p></li></ul><h4 id="in，max，min在元组中的使用">in，max，min在元组中的使用</h4><ul class="lvl-0"><li class="lvl-2"><p>1 in （1，2，3，4） -&gt; True；10 not in （1，2，3，4） -&gt; True</p></li><li class="lvl-2"><p>max((1,2,3,4)) -&gt; 4</p></li><li class="lvl-2"><p>min((1,2,3,4)) -&gt; 1</p></li><li class="lvl-2"><p>max和min在元组中使用的时候，元组中的元素不能是多种类型，如果类型不统一，则会报错</p></li></ul><h3 id="字典类型">字典类型</h3><ul class="lvl-0"><li class="lvl-2"><p>字典是由多个键（key）及其对应的值（value）所组成的一种数据类型</p></li></ul><h4 id="字典的结构与创建方法">字典的结构与创建方法</h4><ul class="lvl-0"><li class="lvl-2"><p>在python中，<mark>dict</mark>用来代表字典，并且可以创建一个字典</p></li><li class="lvl-2"><p>在python中，通过{}将一个个key与value存入字典中</p><p><code>a = dict()</code></p><p><code>a = {}</code></p><p><code>person = {'name':'xiaoming','age':33}</code></p></li></ul><h4 id="字典支持的数据类型">字典支持的数据类型</h4><ul class="lvl-0"><li class="lvl-2"><p>key支持字符串，数字和元组类型，但列表是不支持的</p></li><li class="lvl-2"><p>value支持所有python的数据类型</p><p><code>a = {'name':'dewei','age':30}</code></p><p><code>b = {1:'one',2:'two'}</code></p><p><code>c = {(1,2,3):[1,2,3],(4,5,6):[4,5,6]}</code></p></li></ul><h4 id="列表与元组中的字典">列表与元组中的字典</h4><ul class="lvl-0"><li class="lvl-2"><p>dict_array = [{1:1,2:2},{‘one’:1,‘two’:2}]</p></li><li class="lvl-2"><p>dict_tuple = ({1:1,2:2},{‘one’:1,"two’:2})</p></li><li class="lvl-2"><p><mark>元组一旦创建，就不可以改变</mark></p></li></ul><h4 id="python3-7与之前版本-字典的区别">python3.7与之前版本 字典的区别</h4><ul class="lvl-0"><li class="lvl-2"><p>python3.7之前是无序的</p></li><li class="lvl-2"><p>python3.7之后是有序的</p></li></ul><h4 id="字典的重要特性">字典的重要特性</h4><ul class="lvl-0"><li class="lvl-2"><p>字典中每一个key一定是唯一的</p></li></ul><h3 id="数字的运算">数字的运算</h3><h4 id="赋值运算符">赋值运算符</h4><table><thead><tr><th>运算符</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>=</td><td>等于运算符</td><td>c=a+b</td></tr><tr><td>+=</td><td>加法运算符</td><td>c+=a -&gt; c=c+a</td></tr><tr><td>-=</td><td>减法运算符</td><td>c-=a -&gt; c=c-a</td></tr><tr><td>*=</td><td>乘法运算符</td><td>c*=a  -&gt;  c=c * a</td></tr><tr><td>/=</td><td>除法运算符</td><td>c/=a -&gt; c=c/a</td></tr><tr><td>%=</td><td>取模运算符</td><td>c%=a -&gt; c=c%a</td></tr><tr><td>**=</td><td>幂运算符</td><td>c ** =a -&gt; c=c ** a</td></tr><tr><td>//=</td><td>整除运算符</td><td>c//=a -&gt; c=c//a</td></tr></tbody></table><h4 id="b-kb-mb-gb-的转换">b kb mb gb 的转换</h4><ul class="lvl-0"><li class="lvl-2"><p>b kb mb gb 是计算机的计量单位</p></li><li class="lvl-2"><p>1024相差量</p></li></ul><h4 id="字符串与数字的乘法">字符串与数字的乘法</h4><ul class="lvl-0"><li class="lvl-2"><p>字符串无法与字符串做乘法</p></li><li class="lvl-2"><p>字符串只可以和数字作乘法</p></li></ul><h3 id="比较运算符">比较运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>==</td><td>判断是否等于</td><td>a==b</td></tr><tr><td>!=</td><td>判断是否不等于</td><td>a!=b</td></tr><tr><td>&gt;</td><td>判断是否大于</td><td>a&gt;b</td></tr><tr><td>&lt;</td><td>判断是否小于</td><td>a&lt;b</td></tr><tr><td>&gt;=</td><td>判断是否大于等于</td><td>a&gt;=b</td></tr><tr><td>&lt;=</td><td>判断是否小于等于</td><td>a&lt;=b</td></tr><tr><td><mark>&lt;&gt;</mark></td><td><mark>判断是否不等于</mark></td><td>a&lt;&gt;b</td></tr><tr><td>is</td><td>判断两个对象存储单元是否相同</td><td>a is b</td></tr><tr><td>is not</td><td>判断两个对象存储单元是否不同</td><td>a is not b</td></tr></tbody></table><blockquote><p>注：&lt;&gt;在python3里已经废弃，仅python2里可用</p><p>​       <mark>单元存储</mark> 就是我们提过的<mark>内存块</mark></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
